// Code generated by tool. DO NOT EDIT.
// See the code_generation package.

package single_threaded

import (
	"errors"
	"fmt"

	"github.com/klippa-app/go-pdfium/requests"
	"github.com/klippa-app/go-pdfium/responses"
)

func (i *pdfiumInstance) FPDFAction_GetDest(request *requests.FPDFAction_GetDest) (resp *responses.FPDFAction_GetDest, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFAction_GetDest", panicError)
		}
	}()

	return i.pdfium.FPDFAction_GetDest(request)
}

func (i *pdfiumInstance) FPDFAction_GetFilePath(request *requests.FPDFAction_GetFilePath) (resp *responses.FPDFAction_GetFilePath, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFAction_GetFilePath", panicError)
		}
	}()

	return i.pdfium.FPDFAction_GetFilePath(request)
}

func (i *pdfiumInstance) FPDFAction_GetType(request *requests.FPDFAction_GetType) (resp *responses.FPDFAction_GetType, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFAction_GetType", panicError)
		}
	}()

	return i.pdfium.FPDFAction_GetType(request)
}

func (i *pdfiumInstance) FPDFAction_GetURIPath(request *requests.FPDFAction_GetURIPath) (resp *responses.FPDFAction_GetURIPath, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFAction_GetURIPath", panicError)
		}
	}()

	return i.pdfium.FPDFAction_GetURIPath(request)
}

func (i *pdfiumInstance) FPDFAttachment_GetFile(request *requests.FPDFAttachment_GetFile) (resp *responses.FPDFAttachment_GetFile, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFAttachment_GetFile", panicError)
		}
	}()

	return i.pdfium.FPDFAttachment_GetFile(request)
}

func (i *pdfiumInstance) FPDFAttachment_GetName(request *requests.FPDFAttachment_GetName) (resp *responses.FPDFAttachment_GetName, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFAttachment_GetName", panicError)
		}
	}()

	return i.pdfium.FPDFAttachment_GetName(request)
}

func (i *pdfiumInstance) FPDFAttachment_GetStringValue(request *requests.FPDFAttachment_GetStringValue) (resp *responses.FPDFAttachment_GetStringValue, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFAttachment_GetStringValue", panicError)
		}
	}()

	return i.pdfium.FPDFAttachment_GetStringValue(request)
}

func (i *pdfiumInstance) FPDFAttachment_GetValueType(request *requests.FPDFAttachment_GetValueType) (resp *responses.FPDFAttachment_GetValueType, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFAttachment_GetValueType", panicError)
		}
	}()

	return i.pdfium.FPDFAttachment_GetValueType(request)
}

func (i *pdfiumInstance) FPDFAttachment_HasKey(request *requests.FPDFAttachment_HasKey) (resp *responses.FPDFAttachment_HasKey, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFAttachment_HasKey", panicError)
		}
	}()

	return i.pdfium.FPDFAttachment_HasKey(request)
}

func (i *pdfiumInstance) FPDFAttachment_SetFile(request *requests.FPDFAttachment_SetFile) (resp *responses.FPDFAttachment_SetFile, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFAttachment_SetFile", panicError)
		}
	}()

	return i.pdfium.FPDFAttachment_SetFile(request)
}

func (i *pdfiumInstance) FPDFAttachment_SetStringValue(request *requests.FPDFAttachment_SetStringValue) (resp *responses.FPDFAttachment_SetStringValue, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFAttachment_SetStringValue", panicError)
		}
	}()

	return i.pdfium.FPDFAttachment_SetStringValue(request)
}

func (i *pdfiumInstance) FPDFAvail_Create(request *requests.FPDFAvail_Create) (resp *responses.FPDFAvail_Create, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFAvail_Create", panicError)
		}
	}()

	return i.pdfium.FPDFAvail_Create(request)
}

func (i *pdfiumInstance) FPDFAvail_Destroy(request *requests.FPDFAvail_Destroy) (resp *responses.FPDFAvail_Destroy, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFAvail_Destroy", panicError)
		}
	}()

	return i.pdfium.FPDFAvail_Destroy(request)
}

func (i *pdfiumInstance) FPDFAvail_GetDocument(request *requests.FPDFAvail_GetDocument) (resp *responses.FPDFAvail_GetDocument, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFAvail_GetDocument", panicError)
		}
	}()

	return i.pdfium.FPDFAvail_GetDocument(request)
}

func (i *pdfiumInstance) FPDFAvail_GetFirstPageNum(request *requests.FPDFAvail_GetFirstPageNum) (resp *responses.FPDFAvail_GetFirstPageNum, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFAvail_GetFirstPageNum", panicError)
		}
	}()

	return i.pdfium.FPDFAvail_GetFirstPageNum(request)
}

func (i *pdfiumInstance) FPDFAvail_IsDocAvail(request *requests.FPDFAvail_IsDocAvail) (resp *responses.FPDFAvail_IsDocAvail, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFAvail_IsDocAvail", panicError)
		}
	}()

	return i.pdfium.FPDFAvail_IsDocAvail(request)
}

func (i *pdfiumInstance) FPDFAvail_IsFormAvail(request *requests.FPDFAvail_IsFormAvail) (resp *responses.FPDFAvail_IsFormAvail, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFAvail_IsFormAvail", panicError)
		}
	}()

	return i.pdfium.FPDFAvail_IsFormAvail(request)
}

func (i *pdfiumInstance) FPDFAvail_IsLinearized(request *requests.FPDFAvail_IsLinearized) (resp *responses.FPDFAvail_IsLinearized, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFAvail_IsLinearized", panicError)
		}
	}()

	return i.pdfium.FPDFAvail_IsLinearized(request)
}

func (i *pdfiumInstance) FPDFAvail_IsPageAvail(request *requests.FPDFAvail_IsPageAvail) (resp *responses.FPDFAvail_IsPageAvail, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFAvail_IsPageAvail", panicError)
		}
	}()

	return i.pdfium.FPDFAvail_IsPageAvail(request)
}

func (i *pdfiumInstance) FPDFBitmap_Create(request *requests.FPDFBitmap_Create) (resp *responses.FPDFBitmap_Create, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFBitmap_Create", panicError)
		}
	}()

	return i.pdfium.FPDFBitmap_Create(request)
}

func (i *pdfiumInstance) FPDFBitmap_CreateEx(request *requests.FPDFBitmap_CreateEx) (resp *responses.FPDFBitmap_CreateEx, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFBitmap_CreateEx", panicError)
		}
	}()

	return i.pdfium.FPDFBitmap_CreateEx(request)
}

func (i *pdfiumInstance) FPDFBitmap_Destroy(request *requests.FPDFBitmap_Destroy) (resp *responses.FPDFBitmap_Destroy, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFBitmap_Destroy", panicError)
		}
	}()

	return i.pdfium.FPDFBitmap_Destroy(request)
}

func (i *pdfiumInstance) FPDFBitmap_FillRect(request *requests.FPDFBitmap_FillRect) (resp *responses.FPDFBitmap_FillRect, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFBitmap_FillRect", panicError)
		}
	}()

	return i.pdfium.FPDFBitmap_FillRect(request)
}

func (i *pdfiumInstance) FPDFBitmap_GetBuffer(request *requests.FPDFBitmap_GetBuffer) (resp *responses.FPDFBitmap_GetBuffer, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFBitmap_GetBuffer", panicError)
		}
	}()

	return i.pdfium.FPDFBitmap_GetBuffer(request)
}

func (i *pdfiumInstance) FPDFBitmap_GetFormat(request *requests.FPDFBitmap_GetFormat) (resp *responses.FPDFBitmap_GetFormat, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFBitmap_GetFormat", panicError)
		}
	}()

	return i.pdfium.FPDFBitmap_GetFormat(request)
}

func (i *pdfiumInstance) FPDFBitmap_GetHeight(request *requests.FPDFBitmap_GetHeight) (resp *responses.FPDFBitmap_GetHeight, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFBitmap_GetHeight", panicError)
		}
	}()

	return i.pdfium.FPDFBitmap_GetHeight(request)
}

func (i *pdfiumInstance) FPDFBitmap_GetStride(request *requests.FPDFBitmap_GetStride) (resp *responses.FPDFBitmap_GetStride, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFBitmap_GetStride", panicError)
		}
	}()

	return i.pdfium.FPDFBitmap_GetStride(request)
}

func (i *pdfiumInstance) FPDFBitmap_GetWidth(request *requests.FPDFBitmap_GetWidth) (resp *responses.FPDFBitmap_GetWidth, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFBitmap_GetWidth", panicError)
		}
	}()

	return i.pdfium.FPDFBitmap_GetWidth(request)
}

func (i *pdfiumInstance) FPDFBookmark_Find(request *requests.FPDFBookmark_Find) (resp *responses.FPDFBookmark_Find, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFBookmark_Find", panicError)
		}
	}()

	return i.pdfium.FPDFBookmark_Find(request)
}

func (i *pdfiumInstance) FPDFBookmark_GetAction(request *requests.FPDFBookmark_GetAction) (resp *responses.FPDFBookmark_GetAction, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFBookmark_GetAction", panicError)
		}
	}()

	return i.pdfium.FPDFBookmark_GetAction(request)
}

func (i *pdfiumInstance) FPDFBookmark_GetDest(request *requests.FPDFBookmark_GetDest) (resp *responses.FPDFBookmark_GetDest, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFBookmark_GetDest", panicError)
		}
	}()

	return i.pdfium.FPDFBookmark_GetDest(request)
}

func (i *pdfiumInstance) FPDFBookmark_GetFirstChild(request *requests.FPDFBookmark_GetFirstChild) (resp *responses.FPDFBookmark_GetFirstChild, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFBookmark_GetFirstChild", panicError)
		}
	}()

	return i.pdfium.FPDFBookmark_GetFirstChild(request)
}

func (i *pdfiumInstance) FPDFBookmark_GetNextSibling(request *requests.FPDFBookmark_GetNextSibling) (resp *responses.FPDFBookmark_GetNextSibling, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFBookmark_GetNextSibling", panicError)
		}
	}()

	return i.pdfium.FPDFBookmark_GetNextSibling(request)
}

func (i *pdfiumInstance) FPDFBookmark_GetTitle(request *requests.FPDFBookmark_GetTitle) (resp *responses.FPDFBookmark_GetTitle, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFBookmark_GetTitle", panicError)
		}
	}()

	return i.pdfium.FPDFBookmark_GetTitle(request)
}

func (i *pdfiumInstance) FPDFCatalog_IsTagged(request *requests.FPDFCatalog_IsTagged) (resp *responses.FPDFCatalog_IsTagged, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFCatalog_IsTagged", panicError)
		}
	}()

	return i.pdfium.FPDFCatalog_IsTagged(request)
}

func (i *pdfiumInstance) FPDFClipPath_CountPathSegments(request *requests.FPDFClipPath_CountPathSegments) (resp *responses.FPDFClipPath_CountPathSegments, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFClipPath_CountPathSegments", panicError)
		}
	}()

	return i.pdfium.FPDFClipPath_CountPathSegments(request)
}

func (i *pdfiumInstance) FPDFClipPath_CountPaths(request *requests.FPDFClipPath_CountPaths) (resp *responses.FPDFClipPath_CountPaths, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFClipPath_CountPaths", panicError)
		}
	}()

	return i.pdfium.FPDFClipPath_CountPaths(request)
}

func (i *pdfiumInstance) FPDFClipPath_GetPathSegment(request *requests.FPDFClipPath_GetPathSegment) (resp *responses.FPDFClipPath_GetPathSegment, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFClipPath_GetPathSegment", panicError)
		}
	}()

	return i.pdfium.FPDFClipPath_GetPathSegment(request)
}

func (i *pdfiumInstance) FPDFDest_GetDestPageIndex(request *requests.FPDFDest_GetDestPageIndex) (resp *responses.FPDFDest_GetDestPageIndex, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFDest_GetDestPageIndex", panicError)
		}
	}()

	return i.pdfium.FPDFDest_GetDestPageIndex(request)
}

func (i *pdfiumInstance) FPDFDest_GetLocationInPage(request *requests.FPDFDest_GetLocationInPage) (resp *responses.FPDFDest_GetLocationInPage, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFDest_GetLocationInPage", panicError)
		}
	}()

	return i.pdfium.FPDFDest_GetLocationInPage(request)
}

func (i *pdfiumInstance) FPDFDest_GetView(request *requests.FPDFDest_GetView) (resp *responses.FPDFDest_GetView, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFDest_GetView", panicError)
		}
	}()

	return i.pdfium.FPDFDest_GetView(request)
}

func (i *pdfiumInstance) FPDFDoc_AddAttachment(request *requests.FPDFDoc_AddAttachment) (resp *responses.FPDFDoc_AddAttachment, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFDoc_AddAttachment", panicError)
		}
	}()

	return i.pdfium.FPDFDoc_AddAttachment(request)
}

func (i *pdfiumInstance) FPDFDoc_CloseJavaScriptAction(request *requests.FPDFDoc_CloseJavaScriptAction) (resp *responses.FPDFDoc_CloseJavaScriptAction, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFDoc_CloseJavaScriptAction", panicError)
		}
	}()

	return i.pdfium.FPDFDoc_CloseJavaScriptAction(request)
}

func (i *pdfiumInstance) FPDFDoc_DeleteAttachment(request *requests.FPDFDoc_DeleteAttachment) (resp *responses.FPDFDoc_DeleteAttachment, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFDoc_DeleteAttachment", panicError)
		}
	}()

	return i.pdfium.FPDFDoc_DeleteAttachment(request)
}

func (i *pdfiumInstance) FPDFDoc_GetAttachment(request *requests.FPDFDoc_GetAttachment) (resp *responses.FPDFDoc_GetAttachment, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFDoc_GetAttachment", panicError)
		}
	}()

	return i.pdfium.FPDFDoc_GetAttachment(request)
}

func (i *pdfiumInstance) FPDFDoc_GetAttachmentCount(request *requests.FPDFDoc_GetAttachmentCount) (resp *responses.FPDFDoc_GetAttachmentCount, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFDoc_GetAttachmentCount", panicError)
		}
	}()

	return i.pdfium.FPDFDoc_GetAttachmentCount(request)
}

func (i *pdfiumInstance) FPDFDoc_GetJavaScriptAction(request *requests.FPDFDoc_GetJavaScriptAction) (resp *responses.FPDFDoc_GetJavaScriptAction, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFDoc_GetJavaScriptAction", panicError)
		}
	}()

	return i.pdfium.FPDFDoc_GetJavaScriptAction(request)
}

func (i *pdfiumInstance) FPDFDoc_GetJavaScriptActionCount(request *requests.FPDFDoc_GetJavaScriptActionCount) (resp *responses.FPDFDoc_GetJavaScriptActionCount, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFDoc_GetJavaScriptActionCount", panicError)
		}
	}()

	return i.pdfium.FPDFDoc_GetJavaScriptActionCount(request)
}

func (i *pdfiumInstance) FPDFDoc_GetPageMode(request *requests.FPDFDoc_GetPageMode) (resp *responses.FPDFDoc_GetPageMode, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFDoc_GetPageMode", panicError)
		}
	}()

	return i.pdfium.FPDFDoc_GetPageMode(request)
}

func (i *pdfiumInstance) FPDFFont_Close(request *requests.FPDFFont_Close) (resp *responses.FPDFFont_Close, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFFont_Close", panicError)
		}
	}()

	return i.pdfium.FPDFFont_Close(request)
}

func (i *pdfiumInstance) FPDFFont_GetAscent(request *requests.FPDFFont_GetAscent) (resp *responses.FPDFFont_GetAscent, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFFont_GetAscent", panicError)
		}
	}()

	return i.pdfium.FPDFFont_GetAscent(request)
}

func (i *pdfiumInstance) FPDFFont_GetDescent(request *requests.FPDFFont_GetDescent) (resp *responses.FPDFFont_GetDescent, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFFont_GetDescent", panicError)
		}
	}()

	return i.pdfium.FPDFFont_GetDescent(request)
}

func (i *pdfiumInstance) FPDFFont_GetFlags(request *requests.FPDFFont_GetFlags) (resp *responses.FPDFFont_GetFlags, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFFont_GetFlags", panicError)
		}
	}()

	return i.pdfium.FPDFFont_GetFlags(request)
}

func (i *pdfiumInstance) FPDFFont_GetFontName(request *requests.FPDFFont_GetFontName) (resp *responses.FPDFFont_GetFontName, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFFont_GetFontName", panicError)
		}
	}()

	return i.pdfium.FPDFFont_GetFontName(request)
}

func (i *pdfiumInstance) FPDFFont_GetGlyphPath(request *requests.FPDFFont_GetGlyphPath) (resp *responses.FPDFFont_GetGlyphPath, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFFont_GetGlyphPath", panicError)
		}
	}()

	return i.pdfium.FPDFFont_GetGlyphPath(request)
}

func (i *pdfiumInstance) FPDFFont_GetGlyphWidth(request *requests.FPDFFont_GetGlyphWidth) (resp *responses.FPDFFont_GetGlyphWidth, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFFont_GetGlyphWidth", panicError)
		}
	}()

	return i.pdfium.FPDFFont_GetGlyphWidth(request)
}

func (i *pdfiumInstance) FPDFFont_GetItalicAngle(request *requests.FPDFFont_GetItalicAngle) (resp *responses.FPDFFont_GetItalicAngle, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFFont_GetItalicAngle", panicError)
		}
	}()

	return i.pdfium.FPDFFont_GetItalicAngle(request)
}

func (i *pdfiumInstance) FPDFFont_GetWeight(request *requests.FPDFFont_GetWeight) (resp *responses.FPDFFont_GetWeight, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFFont_GetWeight", panicError)
		}
	}()

	return i.pdfium.FPDFFont_GetWeight(request)
}

func (i *pdfiumInstance) FPDFFormObj_CountObjects(request *requests.FPDFFormObj_CountObjects) (resp *responses.FPDFFormObj_CountObjects, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFFormObj_CountObjects", panicError)
		}
	}()

	return i.pdfium.FPDFFormObj_CountObjects(request)
}

func (i *pdfiumInstance) FPDFFormObj_GetObject(request *requests.FPDFFormObj_GetObject) (resp *responses.FPDFFormObj_GetObject, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFFormObj_GetObject", panicError)
		}
	}()

	return i.pdfium.FPDFFormObj_GetObject(request)
}

func (i *pdfiumInstance) FPDFGlyphPath_CountGlyphSegments(request *requests.FPDFGlyphPath_CountGlyphSegments) (resp *responses.FPDFGlyphPath_CountGlyphSegments, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFGlyphPath_CountGlyphSegments", panicError)
		}
	}()

	return i.pdfium.FPDFGlyphPath_CountGlyphSegments(request)
}

func (i *pdfiumInstance) FPDFGlyphPath_GetGlyphPathSegment(request *requests.FPDFGlyphPath_GetGlyphPathSegment) (resp *responses.FPDFGlyphPath_GetGlyphPathSegment, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFGlyphPath_GetGlyphPathSegment", panicError)
		}
	}()

	return i.pdfium.FPDFGlyphPath_GetGlyphPathSegment(request)
}

func (i *pdfiumInstance) FPDFImageObj_GetBitmap(request *requests.FPDFImageObj_GetBitmap) (resp *responses.FPDFImageObj_GetBitmap, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFImageObj_GetBitmap", panicError)
		}
	}()

	return i.pdfium.FPDFImageObj_GetBitmap(request)
}

func (i *pdfiumInstance) FPDFImageObj_GetImageDataDecoded(request *requests.FPDFImageObj_GetImageDataDecoded) (resp *responses.FPDFImageObj_GetImageDataDecoded, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFImageObj_GetImageDataDecoded", panicError)
		}
	}()

	return i.pdfium.FPDFImageObj_GetImageDataDecoded(request)
}

func (i *pdfiumInstance) FPDFImageObj_GetImageDataRaw(request *requests.FPDFImageObj_GetImageDataRaw) (resp *responses.FPDFImageObj_GetImageDataRaw, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFImageObj_GetImageDataRaw", panicError)
		}
	}()

	return i.pdfium.FPDFImageObj_GetImageDataRaw(request)
}

func (i *pdfiumInstance) FPDFImageObj_GetImageFilter(request *requests.FPDFImageObj_GetImageFilter) (resp *responses.FPDFImageObj_GetImageFilter, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFImageObj_GetImageFilter", panicError)
		}
	}()

	return i.pdfium.FPDFImageObj_GetImageFilter(request)
}

func (i *pdfiumInstance) FPDFImageObj_GetImageFilterCount(request *requests.FPDFImageObj_GetImageFilterCount) (resp *responses.FPDFImageObj_GetImageFilterCount, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFImageObj_GetImageFilterCount", panicError)
		}
	}()

	return i.pdfium.FPDFImageObj_GetImageFilterCount(request)
}

func (i *pdfiumInstance) FPDFImageObj_GetImageMetadata(request *requests.FPDFImageObj_GetImageMetadata) (resp *responses.FPDFImageObj_GetImageMetadata, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFImageObj_GetImageMetadata", panicError)
		}
	}()

	return i.pdfium.FPDFImageObj_GetImageMetadata(request)
}

func (i *pdfiumInstance) FPDFImageObj_GetRenderedBitmap(request *requests.FPDFImageObj_GetRenderedBitmap) (resp *responses.FPDFImageObj_GetRenderedBitmap, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFImageObj_GetRenderedBitmap", panicError)
		}
	}()

	return i.pdfium.FPDFImageObj_GetRenderedBitmap(request)
}

func (i *pdfiumInstance) FPDFImageObj_LoadJpegFile(request *requests.FPDFImageObj_LoadJpegFile) (resp *responses.FPDFImageObj_LoadJpegFile, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFImageObj_LoadJpegFile", panicError)
		}
	}()

	return i.pdfium.FPDFImageObj_LoadJpegFile(request)
}

func (i *pdfiumInstance) FPDFImageObj_LoadJpegFileInline(request *requests.FPDFImageObj_LoadJpegFileInline) (resp *responses.FPDFImageObj_LoadJpegFileInline, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFImageObj_LoadJpegFileInline", panicError)
		}
	}()

	return i.pdfium.FPDFImageObj_LoadJpegFileInline(request)
}

func (i *pdfiumInstance) FPDFImageObj_SetBitmap(request *requests.FPDFImageObj_SetBitmap) (resp *responses.FPDFImageObj_SetBitmap, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFImageObj_SetBitmap", panicError)
		}
	}()

	return i.pdfium.FPDFImageObj_SetBitmap(request)
}

func (i *pdfiumInstance) FPDFImageObj_SetMatrix(request *requests.FPDFImageObj_SetMatrix) (resp *responses.FPDFImageObj_SetMatrix, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFImageObj_SetMatrix", panicError)
		}
	}()

	return i.pdfium.FPDFImageObj_SetMatrix(request)
}

func (i *pdfiumInstance) FPDFJavaScriptAction_GetName(request *requests.FPDFJavaScriptAction_GetName) (resp *responses.FPDFJavaScriptAction_GetName, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFJavaScriptAction_GetName", panicError)
		}
	}()

	return i.pdfium.FPDFJavaScriptAction_GetName(request)
}

func (i *pdfiumInstance) FPDFJavaScriptAction_GetScript(request *requests.FPDFJavaScriptAction_GetScript) (resp *responses.FPDFJavaScriptAction_GetScript, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFJavaScriptAction_GetScript", panicError)
		}
	}()

	return i.pdfium.FPDFJavaScriptAction_GetScript(request)
}

func (i *pdfiumInstance) FPDFLink_CloseWebLinks(request *requests.FPDFLink_CloseWebLinks) (resp *responses.FPDFLink_CloseWebLinks, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFLink_CloseWebLinks", panicError)
		}
	}()

	return i.pdfium.FPDFLink_CloseWebLinks(request)
}

func (i *pdfiumInstance) FPDFLink_CountQuadPoints(request *requests.FPDFLink_CountQuadPoints) (resp *responses.FPDFLink_CountQuadPoints, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFLink_CountQuadPoints", panicError)
		}
	}()

	return i.pdfium.FPDFLink_CountQuadPoints(request)
}

func (i *pdfiumInstance) FPDFLink_CountRects(request *requests.FPDFLink_CountRects) (resp *responses.FPDFLink_CountRects, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFLink_CountRects", panicError)
		}
	}()

	return i.pdfium.FPDFLink_CountRects(request)
}

func (i *pdfiumInstance) FPDFLink_CountWebLinks(request *requests.FPDFLink_CountWebLinks) (resp *responses.FPDFLink_CountWebLinks, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFLink_CountWebLinks", panicError)
		}
	}()

	return i.pdfium.FPDFLink_CountWebLinks(request)
}

func (i *pdfiumInstance) FPDFLink_Enumerate(request *requests.FPDFLink_Enumerate) (resp *responses.FPDFLink_Enumerate, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFLink_Enumerate", panicError)
		}
	}()

	return i.pdfium.FPDFLink_Enumerate(request)
}

func (i *pdfiumInstance) FPDFLink_GetAction(request *requests.FPDFLink_GetAction) (resp *responses.FPDFLink_GetAction, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFLink_GetAction", panicError)
		}
	}()

	return i.pdfium.FPDFLink_GetAction(request)
}

func (i *pdfiumInstance) FPDFLink_GetAnnot(request *requests.FPDFLink_GetAnnot) (resp *responses.FPDFLink_GetAnnot, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFLink_GetAnnot", panicError)
		}
	}()

	return i.pdfium.FPDFLink_GetAnnot(request)
}

func (i *pdfiumInstance) FPDFLink_GetAnnotRect(request *requests.FPDFLink_GetAnnotRect) (resp *responses.FPDFLink_GetAnnotRect, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFLink_GetAnnotRect", panicError)
		}
	}()

	return i.pdfium.FPDFLink_GetAnnotRect(request)
}

func (i *pdfiumInstance) FPDFLink_GetDest(request *requests.FPDFLink_GetDest) (resp *responses.FPDFLink_GetDest, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFLink_GetDest", panicError)
		}
	}()

	return i.pdfium.FPDFLink_GetDest(request)
}

func (i *pdfiumInstance) FPDFLink_GetLinkAtPoint(request *requests.FPDFLink_GetLinkAtPoint) (resp *responses.FPDFLink_GetLinkAtPoint, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFLink_GetLinkAtPoint", panicError)
		}
	}()

	return i.pdfium.FPDFLink_GetLinkAtPoint(request)
}

func (i *pdfiumInstance) FPDFLink_GetLinkZOrderAtPoint(request *requests.FPDFLink_GetLinkZOrderAtPoint) (resp *responses.FPDFLink_GetLinkZOrderAtPoint, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFLink_GetLinkZOrderAtPoint", panicError)
		}
	}()

	return i.pdfium.FPDFLink_GetLinkZOrderAtPoint(request)
}

func (i *pdfiumInstance) FPDFLink_GetQuadPoints(request *requests.FPDFLink_GetQuadPoints) (resp *responses.FPDFLink_GetQuadPoints, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFLink_GetQuadPoints", panicError)
		}
	}()

	return i.pdfium.FPDFLink_GetQuadPoints(request)
}

func (i *pdfiumInstance) FPDFLink_GetRect(request *requests.FPDFLink_GetRect) (resp *responses.FPDFLink_GetRect, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFLink_GetRect", panicError)
		}
	}()

	return i.pdfium.FPDFLink_GetRect(request)
}

func (i *pdfiumInstance) FPDFLink_GetTextRange(request *requests.FPDFLink_GetTextRange) (resp *responses.FPDFLink_GetTextRange, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFLink_GetTextRange", panicError)
		}
	}()

	return i.pdfium.FPDFLink_GetTextRange(request)
}

func (i *pdfiumInstance) FPDFLink_GetURL(request *requests.FPDFLink_GetURL) (resp *responses.FPDFLink_GetURL, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFLink_GetURL", panicError)
		}
	}()

	return i.pdfium.FPDFLink_GetURL(request)
}

func (i *pdfiumInstance) FPDFLink_LoadWebLinks(request *requests.FPDFLink_LoadWebLinks) (resp *responses.FPDFLink_LoadWebLinks, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFLink_LoadWebLinks", panicError)
		}
	}()

	return i.pdfium.FPDFLink_LoadWebLinks(request)
}

func (i *pdfiumInstance) FPDFPageObjMark_CountParams(request *requests.FPDFPageObjMark_CountParams) (resp *responses.FPDFPageObjMark_CountParams, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFPageObjMark_CountParams", panicError)
		}
	}()

	return i.pdfium.FPDFPageObjMark_CountParams(request)
}

func (i *pdfiumInstance) FPDFPageObjMark_GetName(request *requests.FPDFPageObjMark_GetName) (resp *responses.FPDFPageObjMark_GetName, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFPageObjMark_GetName", panicError)
		}
	}()

	return i.pdfium.FPDFPageObjMark_GetName(request)
}

func (i *pdfiumInstance) FPDFPageObjMark_GetParamBlobValue(request *requests.FPDFPageObjMark_GetParamBlobValue) (resp *responses.FPDFPageObjMark_GetParamBlobValue, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFPageObjMark_GetParamBlobValue", panicError)
		}
	}()

	return i.pdfium.FPDFPageObjMark_GetParamBlobValue(request)
}

func (i *pdfiumInstance) FPDFPageObjMark_GetParamIntValue(request *requests.FPDFPageObjMark_GetParamIntValue) (resp *responses.FPDFPageObjMark_GetParamIntValue, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFPageObjMark_GetParamIntValue", panicError)
		}
	}()

	return i.pdfium.FPDFPageObjMark_GetParamIntValue(request)
}

func (i *pdfiumInstance) FPDFPageObjMark_GetParamKey(request *requests.FPDFPageObjMark_GetParamKey) (resp *responses.FPDFPageObjMark_GetParamKey, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFPageObjMark_GetParamKey", panicError)
		}
	}()

	return i.pdfium.FPDFPageObjMark_GetParamKey(request)
}

func (i *pdfiumInstance) FPDFPageObjMark_GetParamStringValue(request *requests.FPDFPageObjMark_GetParamStringValue) (resp *responses.FPDFPageObjMark_GetParamStringValue, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFPageObjMark_GetParamStringValue", panicError)
		}
	}()

	return i.pdfium.FPDFPageObjMark_GetParamStringValue(request)
}

func (i *pdfiumInstance) FPDFPageObjMark_GetParamValueType(request *requests.FPDFPageObjMark_GetParamValueType) (resp *responses.FPDFPageObjMark_GetParamValueType, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFPageObjMark_GetParamValueType", panicError)
		}
	}()

	return i.pdfium.FPDFPageObjMark_GetParamValueType(request)
}

func (i *pdfiumInstance) FPDFPageObjMark_RemoveParam(request *requests.FPDFPageObjMark_RemoveParam) (resp *responses.FPDFPageObjMark_RemoveParam, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFPageObjMark_RemoveParam", panicError)
		}
	}()

	return i.pdfium.FPDFPageObjMark_RemoveParam(request)
}

func (i *pdfiumInstance) FPDFPageObjMark_SetBlobParam(request *requests.FPDFPageObjMark_SetBlobParam) (resp *responses.FPDFPageObjMark_SetBlobParam, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFPageObjMark_SetBlobParam", panicError)
		}
	}()

	return i.pdfium.FPDFPageObjMark_SetBlobParam(request)
}

func (i *pdfiumInstance) FPDFPageObjMark_SetIntParam(request *requests.FPDFPageObjMark_SetIntParam) (resp *responses.FPDFPageObjMark_SetIntParam, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFPageObjMark_SetIntParam", panicError)
		}
	}()

	return i.pdfium.FPDFPageObjMark_SetIntParam(request)
}

func (i *pdfiumInstance) FPDFPageObjMark_SetStringParam(request *requests.FPDFPageObjMark_SetStringParam) (resp *responses.FPDFPageObjMark_SetStringParam, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFPageObjMark_SetStringParam", panicError)
		}
	}()

	return i.pdfium.FPDFPageObjMark_SetStringParam(request)
}

func (i *pdfiumInstance) FPDFPageObj_AddMark(request *requests.FPDFPageObj_AddMark) (resp *responses.FPDFPageObj_AddMark, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFPageObj_AddMark", panicError)
		}
	}()

	return i.pdfium.FPDFPageObj_AddMark(request)
}

func (i *pdfiumInstance) FPDFPageObj_CountMarks(request *requests.FPDFPageObj_CountMarks) (resp *responses.FPDFPageObj_CountMarks, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFPageObj_CountMarks", panicError)
		}
	}()

	return i.pdfium.FPDFPageObj_CountMarks(request)
}

func (i *pdfiumInstance) FPDFPageObj_CreateNewPath(request *requests.FPDFPageObj_CreateNewPath) (resp *responses.FPDFPageObj_CreateNewPath, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFPageObj_CreateNewPath", panicError)
		}
	}()

	return i.pdfium.FPDFPageObj_CreateNewPath(request)
}

func (i *pdfiumInstance) FPDFPageObj_CreateNewRect(request *requests.FPDFPageObj_CreateNewRect) (resp *responses.FPDFPageObj_CreateNewRect, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFPageObj_CreateNewRect", panicError)
		}
	}()

	return i.pdfium.FPDFPageObj_CreateNewRect(request)
}

func (i *pdfiumInstance) FPDFPageObj_CreateTextObj(request *requests.FPDFPageObj_CreateTextObj) (resp *responses.FPDFPageObj_CreateTextObj, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFPageObj_CreateTextObj", panicError)
		}
	}()

	return i.pdfium.FPDFPageObj_CreateTextObj(request)
}

func (i *pdfiumInstance) FPDFPageObj_Destroy(request *requests.FPDFPageObj_Destroy) (resp *responses.FPDFPageObj_Destroy, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFPageObj_Destroy", panicError)
		}
	}()

	return i.pdfium.FPDFPageObj_Destroy(request)
}

func (i *pdfiumInstance) FPDFPageObj_GetBounds(request *requests.FPDFPageObj_GetBounds) (resp *responses.FPDFPageObj_GetBounds, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFPageObj_GetBounds", panicError)
		}
	}()

	return i.pdfium.FPDFPageObj_GetBounds(request)
}

func (i *pdfiumInstance) FPDFPageObj_GetClipPath(request *requests.FPDFPageObj_GetClipPath) (resp *responses.FPDFPageObj_GetClipPath, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFPageObj_GetClipPath", panicError)
		}
	}()

	return i.pdfium.FPDFPageObj_GetClipPath(request)
}

func (i *pdfiumInstance) FPDFPageObj_GetDashArray(request *requests.FPDFPageObj_GetDashArray) (resp *responses.FPDFPageObj_GetDashArray, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFPageObj_GetDashArray", panicError)
		}
	}()

	return i.pdfium.FPDFPageObj_GetDashArray(request)
}

func (i *pdfiumInstance) FPDFPageObj_GetDashCount(request *requests.FPDFPageObj_GetDashCount) (resp *responses.FPDFPageObj_GetDashCount, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFPageObj_GetDashCount", panicError)
		}
	}()

	return i.pdfium.FPDFPageObj_GetDashCount(request)
}

func (i *pdfiumInstance) FPDFPageObj_GetDashPhase(request *requests.FPDFPageObj_GetDashPhase) (resp *responses.FPDFPageObj_GetDashPhase, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFPageObj_GetDashPhase", panicError)
		}
	}()

	return i.pdfium.FPDFPageObj_GetDashPhase(request)
}

func (i *pdfiumInstance) FPDFPageObj_GetFillColor(request *requests.FPDFPageObj_GetFillColor) (resp *responses.FPDFPageObj_GetFillColor, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFPageObj_GetFillColor", panicError)
		}
	}()

	return i.pdfium.FPDFPageObj_GetFillColor(request)
}

func (i *pdfiumInstance) FPDFPageObj_GetLineCap(request *requests.FPDFPageObj_GetLineCap) (resp *responses.FPDFPageObj_GetLineCap, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFPageObj_GetLineCap", panicError)
		}
	}()

	return i.pdfium.FPDFPageObj_GetLineCap(request)
}

func (i *pdfiumInstance) FPDFPageObj_GetLineJoin(request *requests.FPDFPageObj_GetLineJoin) (resp *responses.FPDFPageObj_GetLineJoin, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFPageObj_GetLineJoin", panicError)
		}
	}()

	return i.pdfium.FPDFPageObj_GetLineJoin(request)
}

func (i *pdfiumInstance) FPDFPageObj_GetMark(request *requests.FPDFPageObj_GetMark) (resp *responses.FPDFPageObj_GetMark, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFPageObj_GetMark", panicError)
		}
	}()

	return i.pdfium.FPDFPageObj_GetMark(request)
}

func (i *pdfiumInstance) FPDFPageObj_GetMatrix(request *requests.FPDFPageObj_GetMatrix) (resp *responses.FPDFPageObj_GetMatrix, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFPageObj_GetMatrix", panicError)
		}
	}()

	return i.pdfium.FPDFPageObj_GetMatrix(request)
}

func (i *pdfiumInstance) FPDFPageObj_GetStrokeColor(request *requests.FPDFPageObj_GetStrokeColor) (resp *responses.FPDFPageObj_GetStrokeColor, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFPageObj_GetStrokeColor", panicError)
		}
	}()

	return i.pdfium.FPDFPageObj_GetStrokeColor(request)
}

func (i *pdfiumInstance) FPDFPageObj_GetStrokeWidth(request *requests.FPDFPageObj_GetStrokeWidth) (resp *responses.FPDFPageObj_GetStrokeWidth, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFPageObj_GetStrokeWidth", panicError)
		}
	}()

	return i.pdfium.FPDFPageObj_GetStrokeWidth(request)
}

func (i *pdfiumInstance) FPDFPageObj_GetType(request *requests.FPDFPageObj_GetType) (resp *responses.FPDFPageObj_GetType, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFPageObj_GetType", panicError)
		}
	}()

	return i.pdfium.FPDFPageObj_GetType(request)
}

func (i *pdfiumInstance) FPDFPageObj_HasTransparency(request *requests.FPDFPageObj_HasTransparency) (resp *responses.FPDFPageObj_HasTransparency, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFPageObj_HasTransparency", panicError)
		}
	}()

	return i.pdfium.FPDFPageObj_HasTransparency(request)
}

func (i *pdfiumInstance) FPDFPageObj_NewImageObj(request *requests.FPDFPageObj_NewImageObj) (resp *responses.FPDFPageObj_NewImageObj, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFPageObj_NewImageObj", panicError)
		}
	}()

	return i.pdfium.FPDFPageObj_NewImageObj(request)
}

func (i *pdfiumInstance) FPDFPageObj_NewTextObj(request *requests.FPDFPageObj_NewTextObj) (resp *responses.FPDFPageObj_NewTextObj, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFPageObj_NewTextObj", panicError)
		}
	}()

	return i.pdfium.FPDFPageObj_NewTextObj(request)
}

func (i *pdfiumInstance) FPDFPageObj_RemoveMark(request *requests.FPDFPageObj_RemoveMark) (resp *responses.FPDFPageObj_RemoveMark, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFPageObj_RemoveMark", panicError)
		}
	}()

	return i.pdfium.FPDFPageObj_RemoveMark(request)
}

func (i *pdfiumInstance) FPDFPageObj_SetBlendMode(request *requests.FPDFPageObj_SetBlendMode) (resp *responses.FPDFPageObj_SetBlendMode, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFPageObj_SetBlendMode", panicError)
		}
	}()

	return i.pdfium.FPDFPageObj_SetBlendMode(request)
}

func (i *pdfiumInstance) FPDFPageObj_SetDashArray(request *requests.FPDFPageObj_SetDashArray) (resp *responses.FPDFPageObj_SetDashArray, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFPageObj_SetDashArray", panicError)
		}
	}()

	return i.pdfium.FPDFPageObj_SetDashArray(request)
}

func (i *pdfiumInstance) FPDFPageObj_SetDashPhase(request *requests.FPDFPageObj_SetDashPhase) (resp *responses.FPDFPageObj_SetDashPhase, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFPageObj_SetDashPhase", panicError)
		}
	}()

	return i.pdfium.FPDFPageObj_SetDashPhase(request)
}

func (i *pdfiumInstance) FPDFPageObj_SetFillColor(request *requests.FPDFPageObj_SetFillColor) (resp *responses.FPDFPageObj_SetFillColor, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFPageObj_SetFillColor", panicError)
		}
	}()

	return i.pdfium.FPDFPageObj_SetFillColor(request)
}

func (i *pdfiumInstance) FPDFPageObj_SetLineCap(request *requests.FPDFPageObj_SetLineCap) (resp *responses.FPDFPageObj_SetLineCap, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFPageObj_SetLineCap", panicError)
		}
	}()

	return i.pdfium.FPDFPageObj_SetLineCap(request)
}

func (i *pdfiumInstance) FPDFPageObj_SetLineJoin(request *requests.FPDFPageObj_SetLineJoin) (resp *responses.FPDFPageObj_SetLineJoin, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFPageObj_SetLineJoin", panicError)
		}
	}()

	return i.pdfium.FPDFPageObj_SetLineJoin(request)
}

func (i *pdfiumInstance) FPDFPageObj_SetMatrix(request *requests.FPDFPageObj_SetMatrix) (resp *responses.FPDFPageObj_SetMatrix, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFPageObj_SetMatrix", panicError)
		}
	}()

	return i.pdfium.FPDFPageObj_SetMatrix(request)
}

func (i *pdfiumInstance) FPDFPageObj_SetStrokeColor(request *requests.FPDFPageObj_SetStrokeColor) (resp *responses.FPDFPageObj_SetStrokeColor, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFPageObj_SetStrokeColor", panicError)
		}
	}()

	return i.pdfium.FPDFPageObj_SetStrokeColor(request)
}

func (i *pdfiumInstance) FPDFPageObj_SetStrokeWidth(request *requests.FPDFPageObj_SetStrokeWidth) (resp *responses.FPDFPageObj_SetStrokeWidth, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFPageObj_SetStrokeWidth", panicError)
		}
	}()

	return i.pdfium.FPDFPageObj_SetStrokeWidth(request)
}

func (i *pdfiumInstance) FPDFPageObj_Transform(request *requests.FPDFPageObj_Transform) (resp *responses.FPDFPageObj_Transform, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFPageObj_Transform", panicError)
		}
	}()

	return i.pdfium.FPDFPageObj_Transform(request)
}

func (i *pdfiumInstance) FPDFPageObj_TransformClipPath(request *requests.FPDFPageObj_TransformClipPath) (resp *responses.FPDFPageObj_TransformClipPath, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFPageObj_TransformClipPath", panicError)
		}
	}()

	return i.pdfium.FPDFPageObj_TransformClipPath(request)
}

func (i *pdfiumInstance) FPDFPage_CountObjects(request *requests.FPDFPage_CountObjects) (resp *responses.FPDFPage_CountObjects, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFPage_CountObjects", panicError)
		}
	}()

	return i.pdfium.FPDFPage_CountObjects(request)
}

func (i *pdfiumInstance) FPDFPage_Delete(request *requests.FPDFPage_Delete) (resp *responses.FPDFPage_Delete, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFPage_Delete", panicError)
		}
	}()

	return i.pdfium.FPDFPage_Delete(request)
}

func (i *pdfiumInstance) FPDFPage_Flatten(request *requests.FPDFPage_Flatten) (resp *responses.FPDFPage_Flatten, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFPage_Flatten", panicError)
		}
	}()

	return i.pdfium.FPDFPage_Flatten(request)
}

func (i *pdfiumInstance) FPDFPage_GenerateContent(request *requests.FPDFPage_GenerateContent) (resp *responses.FPDFPage_GenerateContent, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFPage_GenerateContent", panicError)
		}
	}()

	return i.pdfium.FPDFPage_GenerateContent(request)
}

func (i *pdfiumInstance) FPDFPage_GetArtBox(request *requests.FPDFPage_GetArtBox) (resp *responses.FPDFPage_GetArtBox, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFPage_GetArtBox", panicError)
		}
	}()

	return i.pdfium.FPDFPage_GetArtBox(request)
}

func (i *pdfiumInstance) FPDFPage_GetBleedBox(request *requests.FPDFPage_GetBleedBox) (resp *responses.FPDFPage_GetBleedBox, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFPage_GetBleedBox", panicError)
		}
	}()

	return i.pdfium.FPDFPage_GetBleedBox(request)
}

func (i *pdfiumInstance) FPDFPage_GetCropBox(request *requests.FPDFPage_GetCropBox) (resp *responses.FPDFPage_GetCropBox, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFPage_GetCropBox", panicError)
		}
	}()

	return i.pdfium.FPDFPage_GetCropBox(request)
}

func (i *pdfiumInstance) FPDFPage_GetDecodedThumbnailData(request *requests.FPDFPage_GetDecodedThumbnailData) (resp *responses.FPDFPage_GetDecodedThumbnailData, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFPage_GetDecodedThumbnailData", panicError)
		}
	}()

	return i.pdfium.FPDFPage_GetDecodedThumbnailData(request)
}

func (i *pdfiumInstance) FPDFPage_GetMediaBox(request *requests.FPDFPage_GetMediaBox) (resp *responses.FPDFPage_GetMediaBox, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFPage_GetMediaBox", panicError)
		}
	}()

	return i.pdfium.FPDFPage_GetMediaBox(request)
}

func (i *pdfiumInstance) FPDFPage_GetObject(request *requests.FPDFPage_GetObject) (resp *responses.FPDFPage_GetObject, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFPage_GetObject", panicError)
		}
	}()

	return i.pdfium.FPDFPage_GetObject(request)
}

func (i *pdfiumInstance) FPDFPage_GetRawThumbnailData(request *requests.FPDFPage_GetRawThumbnailData) (resp *responses.FPDFPage_GetRawThumbnailData, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFPage_GetRawThumbnailData", panicError)
		}
	}()

	return i.pdfium.FPDFPage_GetRawThumbnailData(request)
}

func (i *pdfiumInstance) FPDFPage_GetRotation(request *requests.FPDFPage_GetRotation) (resp *responses.FPDFPage_GetRotation, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFPage_GetRotation", panicError)
		}
	}()

	return i.pdfium.FPDFPage_GetRotation(request)
}

func (i *pdfiumInstance) FPDFPage_GetThumbnailAsBitmap(request *requests.FPDFPage_GetThumbnailAsBitmap) (resp *responses.FPDFPage_GetThumbnailAsBitmap, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFPage_GetThumbnailAsBitmap", panicError)
		}
	}()

	return i.pdfium.FPDFPage_GetThumbnailAsBitmap(request)
}

func (i *pdfiumInstance) FPDFPage_GetTrimBox(request *requests.FPDFPage_GetTrimBox) (resp *responses.FPDFPage_GetTrimBox, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFPage_GetTrimBox", panicError)
		}
	}()

	return i.pdfium.FPDFPage_GetTrimBox(request)
}

func (i *pdfiumInstance) FPDFPage_HasTransparency(request *requests.FPDFPage_HasTransparency) (resp *responses.FPDFPage_HasTransparency, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFPage_HasTransparency", panicError)
		}
	}()

	return i.pdfium.FPDFPage_HasTransparency(request)
}

func (i *pdfiumInstance) FPDFPage_InsertClipPath(request *requests.FPDFPage_InsertClipPath) (resp *responses.FPDFPage_InsertClipPath, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFPage_InsertClipPath", panicError)
		}
	}()

	return i.pdfium.FPDFPage_InsertClipPath(request)
}

func (i *pdfiumInstance) FPDFPage_InsertObject(request *requests.FPDFPage_InsertObject) (resp *responses.FPDFPage_InsertObject, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFPage_InsertObject", panicError)
		}
	}()

	return i.pdfium.FPDFPage_InsertObject(request)
}

func (i *pdfiumInstance) FPDFPage_New(request *requests.FPDFPage_New) (resp *responses.FPDFPage_New, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFPage_New", panicError)
		}
	}()

	return i.pdfium.FPDFPage_New(request)
}

func (i *pdfiumInstance) FPDFPage_RemoveObject(request *requests.FPDFPage_RemoveObject) (resp *responses.FPDFPage_RemoveObject, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFPage_RemoveObject", panicError)
		}
	}()

	return i.pdfium.FPDFPage_RemoveObject(request)
}

func (i *pdfiumInstance) FPDFPage_SetArtBox(request *requests.FPDFPage_SetArtBox) (resp *responses.FPDFPage_SetArtBox, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFPage_SetArtBox", panicError)
		}
	}()

	return i.pdfium.FPDFPage_SetArtBox(request)
}

func (i *pdfiumInstance) FPDFPage_SetBleedBox(request *requests.FPDFPage_SetBleedBox) (resp *responses.FPDFPage_SetBleedBox, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFPage_SetBleedBox", panicError)
		}
	}()

	return i.pdfium.FPDFPage_SetBleedBox(request)
}

func (i *pdfiumInstance) FPDFPage_SetCropBox(request *requests.FPDFPage_SetCropBox) (resp *responses.FPDFPage_SetCropBox, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFPage_SetCropBox", panicError)
		}
	}()

	return i.pdfium.FPDFPage_SetCropBox(request)
}

func (i *pdfiumInstance) FPDFPage_SetMediaBox(request *requests.FPDFPage_SetMediaBox) (resp *responses.FPDFPage_SetMediaBox, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFPage_SetMediaBox", panicError)
		}
	}()

	return i.pdfium.FPDFPage_SetMediaBox(request)
}

func (i *pdfiumInstance) FPDFPage_SetRotation(request *requests.FPDFPage_SetRotation) (resp *responses.FPDFPage_SetRotation, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFPage_SetRotation", panicError)
		}
	}()

	return i.pdfium.FPDFPage_SetRotation(request)
}

func (i *pdfiumInstance) FPDFPage_SetTrimBox(request *requests.FPDFPage_SetTrimBox) (resp *responses.FPDFPage_SetTrimBox, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFPage_SetTrimBox", panicError)
		}
	}()

	return i.pdfium.FPDFPage_SetTrimBox(request)
}

func (i *pdfiumInstance) FPDFPage_TransFormWithClip(request *requests.FPDFPage_TransFormWithClip) (resp *responses.FPDFPage_TransFormWithClip, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFPage_TransFormWithClip", panicError)
		}
	}()

	return i.pdfium.FPDFPage_TransFormWithClip(request)
}

func (i *pdfiumInstance) FPDFPage_TransformAnnots(request *requests.FPDFPage_TransformAnnots) (resp *responses.FPDFPage_TransformAnnots, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFPage_TransformAnnots", panicError)
		}
	}()

	return i.pdfium.FPDFPage_TransformAnnots(request)
}

func (i *pdfiumInstance) FPDFPathSegment_GetClose(request *requests.FPDFPathSegment_GetClose) (resp *responses.FPDFPathSegment_GetClose, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFPathSegment_GetClose", panicError)
		}
	}()

	return i.pdfium.FPDFPathSegment_GetClose(request)
}

func (i *pdfiumInstance) FPDFPathSegment_GetPoint(request *requests.FPDFPathSegment_GetPoint) (resp *responses.FPDFPathSegment_GetPoint, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFPathSegment_GetPoint", panicError)
		}
	}()

	return i.pdfium.FPDFPathSegment_GetPoint(request)
}

func (i *pdfiumInstance) FPDFPathSegment_GetType(request *requests.FPDFPathSegment_GetType) (resp *responses.FPDFPathSegment_GetType, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFPathSegment_GetType", panicError)
		}
	}()

	return i.pdfium.FPDFPathSegment_GetType(request)
}

func (i *pdfiumInstance) FPDFPath_BezierTo(request *requests.FPDFPath_BezierTo) (resp *responses.FPDFPath_BezierTo, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFPath_BezierTo", panicError)
		}
	}()

	return i.pdfium.FPDFPath_BezierTo(request)
}

func (i *pdfiumInstance) FPDFPath_Close(request *requests.FPDFPath_Close) (resp *responses.FPDFPath_Close, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFPath_Close", panicError)
		}
	}()

	return i.pdfium.FPDFPath_Close(request)
}

func (i *pdfiumInstance) FPDFPath_CountSegments(request *requests.FPDFPath_CountSegments) (resp *responses.FPDFPath_CountSegments, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFPath_CountSegments", panicError)
		}
	}()

	return i.pdfium.FPDFPath_CountSegments(request)
}

func (i *pdfiumInstance) FPDFPath_GetDrawMode(request *requests.FPDFPath_GetDrawMode) (resp *responses.FPDFPath_GetDrawMode, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFPath_GetDrawMode", panicError)
		}
	}()

	return i.pdfium.FPDFPath_GetDrawMode(request)
}

func (i *pdfiumInstance) FPDFPath_GetPathSegment(request *requests.FPDFPath_GetPathSegment) (resp *responses.FPDFPath_GetPathSegment, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFPath_GetPathSegment", panicError)
		}
	}()

	return i.pdfium.FPDFPath_GetPathSegment(request)
}

func (i *pdfiumInstance) FPDFPath_LineTo(request *requests.FPDFPath_LineTo) (resp *responses.FPDFPath_LineTo, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFPath_LineTo", panicError)
		}
	}()

	return i.pdfium.FPDFPath_LineTo(request)
}

func (i *pdfiumInstance) FPDFPath_MoveTo(request *requests.FPDFPath_MoveTo) (resp *responses.FPDFPath_MoveTo, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFPath_MoveTo", panicError)
		}
	}()

	return i.pdfium.FPDFPath_MoveTo(request)
}

func (i *pdfiumInstance) FPDFPath_SetDrawMode(request *requests.FPDFPath_SetDrawMode) (resp *responses.FPDFPath_SetDrawMode, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFPath_SetDrawMode", panicError)
		}
	}()

	return i.pdfium.FPDFPath_SetDrawMode(request)
}

func (i *pdfiumInstance) FPDFSignatureObj_GetByteRange(request *requests.FPDFSignatureObj_GetByteRange) (resp *responses.FPDFSignatureObj_GetByteRange, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFSignatureObj_GetByteRange", panicError)
		}
	}()

	return i.pdfium.FPDFSignatureObj_GetByteRange(request)
}

func (i *pdfiumInstance) FPDFSignatureObj_GetContents(request *requests.FPDFSignatureObj_GetContents) (resp *responses.FPDFSignatureObj_GetContents, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFSignatureObj_GetContents", panicError)
		}
	}()

	return i.pdfium.FPDFSignatureObj_GetContents(request)
}

func (i *pdfiumInstance) FPDFSignatureObj_GetDocMDPPermission(request *requests.FPDFSignatureObj_GetDocMDPPermission) (resp *responses.FPDFSignatureObj_GetDocMDPPermission, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFSignatureObj_GetDocMDPPermission", panicError)
		}
	}()

	return i.pdfium.FPDFSignatureObj_GetDocMDPPermission(request)
}

func (i *pdfiumInstance) FPDFSignatureObj_GetReason(request *requests.FPDFSignatureObj_GetReason) (resp *responses.FPDFSignatureObj_GetReason, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFSignatureObj_GetReason", panicError)
		}
	}()

	return i.pdfium.FPDFSignatureObj_GetReason(request)
}

func (i *pdfiumInstance) FPDFSignatureObj_GetSubFilter(request *requests.FPDFSignatureObj_GetSubFilter) (resp *responses.FPDFSignatureObj_GetSubFilter, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFSignatureObj_GetSubFilter", panicError)
		}
	}()

	return i.pdfium.FPDFSignatureObj_GetSubFilter(request)
}

func (i *pdfiumInstance) FPDFSignatureObj_GetTime(request *requests.FPDFSignatureObj_GetTime) (resp *responses.FPDFSignatureObj_GetTime, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFSignatureObj_GetTime", panicError)
		}
	}()

	return i.pdfium.FPDFSignatureObj_GetTime(request)
}

func (i *pdfiumInstance) FPDFTextObj_GetFont(request *requests.FPDFTextObj_GetFont) (resp *responses.FPDFTextObj_GetFont, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFTextObj_GetFont", panicError)
		}
	}()

	return i.pdfium.FPDFTextObj_GetFont(request)
}

func (i *pdfiumInstance) FPDFTextObj_GetFontSize(request *requests.FPDFTextObj_GetFontSize) (resp *responses.FPDFTextObj_GetFontSize, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFTextObj_GetFontSize", panicError)
		}
	}()

	return i.pdfium.FPDFTextObj_GetFontSize(request)
}

func (i *pdfiumInstance) FPDFTextObj_GetText(request *requests.FPDFTextObj_GetText) (resp *responses.FPDFTextObj_GetText, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFTextObj_GetText", panicError)
		}
	}()

	return i.pdfium.FPDFTextObj_GetText(request)
}

func (i *pdfiumInstance) FPDFTextObj_GetTextRenderMode(request *requests.FPDFTextObj_GetTextRenderMode) (resp *responses.FPDFTextObj_GetTextRenderMode, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFTextObj_GetTextRenderMode", panicError)
		}
	}()

	return i.pdfium.FPDFTextObj_GetTextRenderMode(request)
}

func (i *pdfiumInstance) FPDFTextObj_SetTextRenderMode(request *requests.FPDFTextObj_SetTextRenderMode) (resp *responses.FPDFTextObj_SetTextRenderMode, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFTextObj_SetTextRenderMode", panicError)
		}
	}()

	return i.pdfium.FPDFTextObj_SetTextRenderMode(request)
}

func (i *pdfiumInstance) FPDFText_ClosePage(request *requests.FPDFText_ClosePage) (resp *responses.FPDFText_ClosePage, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFText_ClosePage", panicError)
		}
	}()

	return i.pdfium.FPDFText_ClosePage(request)
}

func (i *pdfiumInstance) FPDFText_CountChars(request *requests.FPDFText_CountChars) (resp *responses.FPDFText_CountChars, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFText_CountChars", panicError)
		}
	}()

	return i.pdfium.FPDFText_CountChars(request)
}

func (i *pdfiumInstance) FPDFText_CountRects(request *requests.FPDFText_CountRects) (resp *responses.FPDFText_CountRects, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFText_CountRects", panicError)
		}
	}()

	return i.pdfium.FPDFText_CountRects(request)
}

func (i *pdfiumInstance) FPDFText_FindClose(request *requests.FPDFText_FindClose) (resp *responses.FPDFText_FindClose, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFText_FindClose", panicError)
		}
	}()

	return i.pdfium.FPDFText_FindClose(request)
}

func (i *pdfiumInstance) FPDFText_FindNext(request *requests.FPDFText_FindNext) (resp *responses.FPDFText_FindNext, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFText_FindNext", panicError)
		}
	}()

	return i.pdfium.FPDFText_FindNext(request)
}

func (i *pdfiumInstance) FPDFText_FindPrev(request *requests.FPDFText_FindPrev) (resp *responses.FPDFText_FindPrev, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFText_FindPrev", panicError)
		}
	}()

	return i.pdfium.FPDFText_FindPrev(request)
}

func (i *pdfiumInstance) FPDFText_FindStart(request *requests.FPDFText_FindStart) (resp *responses.FPDFText_FindStart, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFText_FindStart", panicError)
		}
	}()

	return i.pdfium.FPDFText_FindStart(request)
}

func (i *pdfiumInstance) FPDFText_GetBoundedText(request *requests.FPDFText_GetBoundedText) (resp *responses.FPDFText_GetBoundedText, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFText_GetBoundedText", panicError)
		}
	}()

	return i.pdfium.FPDFText_GetBoundedText(request)
}

func (i *pdfiumInstance) FPDFText_GetCharAngle(request *requests.FPDFText_GetCharAngle) (resp *responses.FPDFText_GetCharAngle, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFText_GetCharAngle", panicError)
		}
	}()

	return i.pdfium.FPDFText_GetCharAngle(request)
}

func (i *pdfiumInstance) FPDFText_GetCharBox(request *requests.FPDFText_GetCharBox) (resp *responses.FPDFText_GetCharBox, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFText_GetCharBox", panicError)
		}
	}()

	return i.pdfium.FPDFText_GetCharBox(request)
}

func (i *pdfiumInstance) FPDFText_GetCharIndexAtPos(request *requests.FPDFText_GetCharIndexAtPos) (resp *responses.FPDFText_GetCharIndexAtPos, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFText_GetCharIndexAtPos", panicError)
		}
	}()

	return i.pdfium.FPDFText_GetCharIndexAtPos(request)
}

func (i *pdfiumInstance) FPDFText_GetCharIndexFromTextIndex(request *requests.FPDFText_GetCharIndexFromTextIndex) (resp *responses.FPDFText_GetCharIndexFromTextIndex, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFText_GetCharIndexFromTextIndex", panicError)
		}
	}()

	return i.pdfium.FPDFText_GetCharIndexFromTextIndex(request)
}

func (i *pdfiumInstance) FPDFText_GetCharOrigin(request *requests.FPDFText_GetCharOrigin) (resp *responses.FPDFText_GetCharOrigin, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFText_GetCharOrigin", panicError)
		}
	}()

	return i.pdfium.FPDFText_GetCharOrigin(request)
}

func (i *pdfiumInstance) FPDFText_GetFillColor(request *requests.FPDFText_GetFillColor) (resp *responses.FPDFText_GetFillColor, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFText_GetFillColor", panicError)
		}
	}()

	return i.pdfium.FPDFText_GetFillColor(request)
}

func (i *pdfiumInstance) FPDFText_GetFontInfo(request *requests.FPDFText_GetFontInfo) (resp *responses.FPDFText_GetFontInfo, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFText_GetFontInfo", panicError)
		}
	}()

	return i.pdfium.FPDFText_GetFontInfo(request)
}

func (i *pdfiumInstance) FPDFText_GetFontSize(request *requests.FPDFText_GetFontSize) (resp *responses.FPDFText_GetFontSize, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFText_GetFontSize", panicError)
		}
	}()

	return i.pdfium.FPDFText_GetFontSize(request)
}

func (i *pdfiumInstance) FPDFText_GetFontWeight(request *requests.FPDFText_GetFontWeight) (resp *responses.FPDFText_GetFontWeight, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFText_GetFontWeight", panicError)
		}
	}()

	return i.pdfium.FPDFText_GetFontWeight(request)
}

func (i *pdfiumInstance) FPDFText_GetLooseCharBox(request *requests.FPDFText_GetLooseCharBox) (resp *responses.FPDFText_GetLooseCharBox, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFText_GetLooseCharBox", panicError)
		}
	}()

	return i.pdfium.FPDFText_GetLooseCharBox(request)
}

func (i *pdfiumInstance) FPDFText_GetMatrix(request *requests.FPDFText_GetMatrix) (resp *responses.FPDFText_GetMatrix, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFText_GetMatrix", panicError)
		}
	}()

	return i.pdfium.FPDFText_GetMatrix(request)
}

func (i *pdfiumInstance) FPDFText_GetRect(request *requests.FPDFText_GetRect) (resp *responses.FPDFText_GetRect, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFText_GetRect", panicError)
		}
	}()

	return i.pdfium.FPDFText_GetRect(request)
}

func (i *pdfiumInstance) FPDFText_GetSchCount(request *requests.FPDFText_GetSchCount) (resp *responses.FPDFText_GetSchCount, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFText_GetSchCount", panicError)
		}
	}()

	return i.pdfium.FPDFText_GetSchCount(request)
}

func (i *pdfiumInstance) FPDFText_GetSchResultIndex(request *requests.FPDFText_GetSchResultIndex) (resp *responses.FPDFText_GetSchResultIndex, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFText_GetSchResultIndex", panicError)
		}
	}()

	return i.pdfium.FPDFText_GetSchResultIndex(request)
}

func (i *pdfiumInstance) FPDFText_GetStrokeColor(request *requests.FPDFText_GetStrokeColor) (resp *responses.FPDFText_GetStrokeColor, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFText_GetStrokeColor", panicError)
		}
	}()

	return i.pdfium.FPDFText_GetStrokeColor(request)
}

func (i *pdfiumInstance) FPDFText_GetText(request *requests.FPDFText_GetText) (resp *responses.FPDFText_GetText, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFText_GetText", panicError)
		}
	}()

	return i.pdfium.FPDFText_GetText(request)
}

func (i *pdfiumInstance) FPDFText_GetTextIndexFromCharIndex(request *requests.FPDFText_GetTextIndexFromCharIndex) (resp *responses.FPDFText_GetTextIndexFromCharIndex, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFText_GetTextIndexFromCharIndex", panicError)
		}
	}()

	return i.pdfium.FPDFText_GetTextIndexFromCharIndex(request)
}

func (i *pdfiumInstance) FPDFText_GetTextRenderMode(request *requests.FPDFText_GetTextRenderMode) (resp *responses.FPDFText_GetTextRenderMode, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFText_GetTextRenderMode", panicError)
		}
	}()

	return i.pdfium.FPDFText_GetTextRenderMode(request)
}

func (i *pdfiumInstance) FPDFText_GetUnicode(request *requests.FPDFText_GetUnicode) (resp *responses.FPDFText_GetUnicode, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFText_GetUnicode", panicError)
		}
	}()

	return i.pdfium.FPDFText_GetUnicode(request)
}

func (i *pdfiumInstance) FPDFText_LoadFont(request *requests.FPDFText_LoadFont) (resp *responses.FPDFText_LoadFont, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFText_LoadFont", panicError)
		}
	}()

	return i.pdfium.FPDFText_LoadFont(request)
}

func (i *pdfiumInstance) FPDFText_LoadPage(request *requests.FPDFText_LoadPage) (resp *responses.FPDFText_LoadPage, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFText_LoadPage", panicError)
		}
	}()

	return i.pdfium.FPDFText_LoadPage(request)
}

func (i *pdfiumInstance) FPDFText_LoadStandardFont(request *requests.FPDFText_LoadStandardFont) (resp *responses.FPDFText_LoadStandardFont, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFText_LoadStandardFont", panicError)
		}
	}()

	return i.pdfium.FPDFText_LoadStandardFont(request)
}

func (i *pdfiumInstance) FPDFText_SetCharcodes(request *requests.FPDFText_SetCharcodes) (resp *responses.FPDFText_SetCharcodes, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFText_SetCharcodes", panicError)
		}
	}()

	return i.pdfium.FPDFText_SetCharcodes(request)
}

func (i *pdfiumInstance) FPDFText_SetText(request *requests.FPDFText_SetText) (resp *responses.FPDFText_SetText, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDFText_SetText", panicError)
		}
	}()

	return i.pdfium.FPDFText_SetText(request)
}

func (i *pdfiumInstance) FPDF_CloseDocument(request *requests.FPDF_CloseDocument) (resp *responses.FPDF_CloseDocument, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDF_CloseDocument", panicError)
		}
	}()

	return i.pdfium.FPDF_CloseDocument(request)
}

func (i *pdfiumInstance) FPDF_ClosePage(request *requests.FPDF_ClosePage) (resp *responses.FPDF_ClosePage, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDF_ClosePage", panicError)
		}
	}()

	return i.pdfium.FPDF_ClosePage(request)
}

func (i *pdfiumInstance) FPDF_CloseXObject(request *requests.FPDF_CloseXObject) (resp *responses.FPDF_CloseXObject, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDF_CloseXObject", panicError)
		}
	}()

	return i.pdfium.FPDF_CloseXObject(request)
}

func (i *pdfiumInstance) FPDF_CopyViewerPreferences(request *requests.FPDF_CopyViewerPreferences) (resp *responses.FPDF_CopyViewerPreferences, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDF_CopyViewerPreferences", panicError)
		}
	}()

	return i.pdfium.FPDF_CopyViewerPreferences(request)
}

func (i *pdfiumInstance) FPDF_CountNamedDests(request *requests.FPDF_CountNamedDests) (resp *responses.FPDF_CountNamedDests, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDF_CountNamedDests", panicError)
		}
	}()

	return i.pdfium.FPDF_CountNamedDests(request)
}

func (i *pdfiumInstance) FPDF_CreateClipPath(request *requests.FPDF_CreateClipPath) (resp *responses.FPDF_CreateClipPath, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDF_CreateClipPath", panicError)
		}
	}()

	return i.pdfium.FPDF_CreateClipPath(request)
}

func (i *pdfiumInstance) FPDF_CreateNewDocument(request *requests.FPDF_CreateNewDocument) (resp *responses.FPDF_CreateNewDocument, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDF_CreateNewDocument", panicError)
		}
	}()

	return i.pdfium.FPDF_CreateNewDocument(request)
}

func (i *pdfiumInstance) FPDF_DestroyClipPath(request *requests.FPDF_DestroyClipPath) (resp *responses.FPDF_DestroyClipPath, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDF_DestroyClipPath", panicError)
		}
	}()

	return i.pdfium.FPDF_DestroyClipPath(request)
}

func (i *pdfiumInstance) FPDF_DeviceToPage(request *requests.FPDF_DeviceToPage) (resp *responses.FPDF_DeviceToPage, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDF_DeviceToPage", panicError)
		}
	}()

	return i.pdfium.FPDF_DeviceToPage(request)
}

func (i *pdfiumInstance) FPDF_DocumentHasValidCrossReferenceTable(request *requests.FPDF_DocumentHasValidCrossReferenceTable) (resp *responses.FPDF_DocumentHasValidCrossReferenceTable, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDF_DocumentHasValidCrossReferenceTable", panicError)
		}
	}()

	return i.pdfium.FPDF_DocumentHasValidCrossReferenceTable(request)
}

func (i *pdfiumInstance) FPDF_GetDocPermissions(request *requests.FPDF_GetDocPermissions) (resp *responses.FPDF_GetDocPermissions, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDF_GetDocPermissions", panicError)
		}
	}()

	return i.pdfium.FPDF_GetDocPermissions(request)
}

func (i *pdfiumInstance) FPDF_GetFileIdentifier(request *requests.FPDF_GetFileIdentifier) (resp *responses.FPDF_GetFileIdentifier, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDF_GetFileIdentifier", panicError)
		}
	}()

	return i.pdfium.FPDF_GetFileIdentifier(request)
}

func (i *pdfiumInstance) FPDF_GetFileVersion(request *requests.FPDF_GetFileVersion) (resp *responses.FPDF_GetFileVersion, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDF_GetFileVersion", panicError)
		}
	}()

	return i.pdfium.FPDF_GetFileVersion(request)
}

func (i *pdfiumInstance) FPDF_GetLastError(request *requests.FPDF_GetLastError) (resp *responses.FPDF_GetLastError, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDF_GetLastError", panicError)
		}
	}()

	return i.pdfium.FPDF_GetLastError(request)
}

func (i *pdfiumInstance) FPDF_GetMetaText(request *requests.FPDF_GetMetaText) (resp *responses.FPDF_GetMetaText, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDF_GetMetaText", panicError)
		}
	}()

	return i.pdfium.FPDF_GetMetaText(request)
}

func (i *pdfiumInstance) FPDF_GetNamedDest(request *requests.FPDF_GetNamedDest) (resp *responses.FPDF_GetNamedDest, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDF_GetNamedDest", panicError)
		}
	}()

	return i.pdfium.FPDF_GetNamedDest(request)
}

func (i *pdfiumInstance) FPDF_GetNamedDestByName(request *requests.FPDF_GetNamedDestByName) (resp *responses.FPDF_GetNamedDestByName, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDF_GetNamedDestByName", panicError)
		}
	}()

	return i.pdfium.FPDF_GetNamedDestByName(request)
}

func (i *pdfiumInstance) FPDF_GetPageAAction(request *requests.FPDF_GetPageAAction) (resp *responses.FPDF_GetPageAAction, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDF_GetPageAAction", panicError)
		}
	}()

	return i.pdfium.FPDF_GetPageAAction(request)
}

func (i *pdfiumInstance) FPDF_GetPageBoundingBox(request *requests.FPDF_GetPageBoundingBox) (resp *responses.FPDF_GetPageBoundingBox, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDF_GetPageBoundingBox", panicError)
		}
	}()

	return i.pdfium.FPDF_GetPageBoundingBox(request)
}

func (i *pdfiumInstance) FPDF_GetPageCount(request *requests.FPDF_GetPageCount) (resp *responses.FPDF_GetPageCount, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDF_GetPageCount", panicError)
		}
	}()

	return i.pdfium.FPDF_GetPageCount(request)
}

func (i *pdfiumInstance) FPDF_GetPageHeight(request *requests.FPDF_GetPageHeight) (resp *responses.FPDF_GetPageHeight, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDF_GetPageHeight", panicError)
		}
	}()

	return i.pdfium.FPDF_GetPageHeight(request)
}

func (i *pdfiumInstance) FPDF_GetPageHeightF(request *requests.FPDF_GetPageHeightF) (resp *responses.FPDF_GetPageHeightF, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDF_GetPageHeightF", panicError)
		}
	}()

	return i.pdfium.FPDF_GetPageHeightF(request)
}

func (i *pdfiumInstance) FPDF_GetPageLabel(request *requests.FPDF_GetPageLabel) (resp *responses.FPDF_GetPageLabel, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDF_GetPageLabel", panicError)
		}
	}()

	return i.pdfium.FPDF_GetPageLabel(request)
}

func (i *pdfiumInstance) FPDF_GetPageSizeByIndex(request *requests.FPDF_GetPageSizeByIndex) (resp *responses.FPDF_GetPageSizeByIndex, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDF_GetPageSizeByIndex", panicError)
		}
	}()

	return i.pdfium.FPDF_GetPageSizeByIndex(request)
}

func (i *pdfiumInstance) FPDF_GetPageSizeByIndexF(request *requests.FPDF_GetPageSizeByIndexF) (resp *responses.FPDF_GetPageSizeByIndexF, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDF_GetPageSizeByIndexF", panicError)
		}
	}()

	return i.pdfium.FPDF_GetPageSizeByIndexF(request)
}

func (i *pdfiumInstance) FPDF_GetPageWidth(request *requests.FPDF_GetPageWidth) (resp *responses.FPDF_GetPageWidth, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDF_GetPageWidth", panicError)
		}
	}()

	return i.pdfium.FPDF_GetPageWidth(request)
}

func (i *pdfiumInstance) FPDF_GetPageWidthF(request *requests.FPDF_GetPageWidthF) (resp *responses.FPDF_GetPageWidthF, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDF_GetPageWidthF", panicError)
		}
	}()

	return i.pdfium.FPDF_GetPageWidthF(request)
}

func (i *pdfiumInstance) FPDF_GetSecurityHandlerRevision(request *requests.FPDF_GetSecurityHandlerRevision) (resp *responses.FPDF_GetSecurityHandlerRevision, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDF_GetSecurityHandlerRevision", panicError)
		}
	}()

	return i.pdfium.FPDF_GetSecurityHandlerRevision(request)
}

func (i *pdfiumInstance) FPDF_GetSignatureCount(request *requests.FPDF_GetSignatureCount) (resp *responses.FPDF_GetSignatureCount, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDF_GetSignatureCount", panicError)
		}
	}()

	return i.pdfium.FPDF_GetSignatureCount(request)
}

func (i *pdfiumInstance) FPDF_GetSignatureObject(request *requests.FPDF_GetSignatureObject) (resp *responses.FPDF_GetSignatureObject, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDF_GetSignatureObject", panicError)
		}
	}()

	return i.pdfium.FPDF_GetSignatureObject(request)
}

func (i *pdfiumInstance) FPDF_GetTrailerEnds(request *requests.FPDF_GetTrailerEnds) (resp *responses.FPDF_GetTrailerEnds, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDF_GetTrailerEnds", panicError)
		}
	}()

	return i.pdfium.FPDF_GetTrailerEnds(request)
}

func (i *pdfiumInstance) FPDF_GetXFAPacketContent(request *requests.FPDF_GetXFAPacketContent) (resp *responses.FPDF_GetXFAPacketContent, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDF_GetXFAPacketContent", panicError)
		}
	}()

	return i.pdfium.FPDF_GetXFAPacketContent(request)
}

func (i *pdfiumInstance) FPDF_GetXFAPacketCount(request *requests.FPDF_GetXFAPacketCount) (resp *responses.FPDF_GetXFAPacketCount, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDF_GetXFAPacketCount", panicError)
		}
	}()

	return i.pdfium.FPDF_GetXFAPacketCount(request)
}

func (i *pdfiumInstance) FPDF_GetXFAPacketName(request *requests.FPDF_GetXFAPacketName) (resp *responses.FPDF_GetXFAPacketName, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDF_GetXFAPacketName", panicError)
		}
	}()

	return i.pdfium.FPDF_GetXFAPacketName(request)
}

func (i *pdfiumInstance) FPDF_ImportNPagesToOne(request *requests.FPDF_ImportNPagesToOne) (resp *responses.FPDF_ImportNPagesToOne, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDF_ImportNPagesToOne", panicError)
		}
	}()

	return i.pdfium.FPDF_ImportNPagesToOne(request)
}

func (i *pdfiumInstance) FPDF_ImportPages(request *requests.FPDF_ImportPages) (resp *responses.FPDF_ImportPages, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDF_ImportPages", panicError)
		}
	}()

	return i.pdfium.FPDF_ImportPages(request)
}

func (i *pdfiumInstance) FPDF_ImportPagesByIndex(request *requests.FPDF_ImportPagesByIndex) (resp *responses.FPDF_ImportPagesByIndex, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDF_ImportPagesByIndex", panicError)
		}
	}()

	return i.pdfium.FPDF_ImportPagesByIndex(request)
}

func (i *pdfiumInstance) FPDF_LoadCustomDocument(request *requests.FPDF_LoadCustomDocument) (resp *responses.FPDF_LoadCustomDocument, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDF_LoadCustomDocument", panicError)
		}
	}()

	return i.pdfium.FPDF_LoadCustomDocument(request)
}

func (i *pdfiumInstance) FPDF_LoadDocument(request *requests.FPDF_LoadDocument) (resp *responses.FPDF_LoadDocument, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDF_LoadDocument", panicError)
		}
	}()

	return i.pdfium.FPDF_LoadDocument(request)
}

func (i *pdfiumInstance) FPDF_LoadMemDocument(request *requests.FPDF_LoadMemDocument) (resp *responses.FPDF_LoadMemDocument, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDF_LoadMemDocument", panicError)
		}
	}()

	return i.pdfium.FPDF_LoadMemDocument(request)
}

func (i *pdfiumInstance) FPDF_LoadMemDocument64(request *requests.FPDF_LoadMemDocument64) (resp *responses.FPDF_LoadMemDocument64, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDF_LoadMemDocument64", panicError)
		}
	}()

	return i.pdfium.FPDF_LoadMemDocument64(request)
}

func (i *pdfiumInstance) FPDF_LoadPage(request *requests.FPDF_LoadPage) (resp *responses.FPDF_LoadPage, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDF_LoadPage", panicError)
		}
	}()

	return i.pdfium.FPDF_LoadPage(request)
}

func (i *pdfiumInstance) FPDF_NewFormObjectFromXObject(request *requests.FPDF_NewFormObjectFromXObject) (resp *responses.FPDF_NewFormObjectFromXObject, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDF_NewFormObjectFromXObject", panicError)
		}
	}()

	return i.pdfium.FPDF_NewFormObjectFromXObject(request)
}

func (i *pdfiumInstance) FPDF_NewXObjectFromPage(request *requests.FPDF_NewXObjectFromPage) (resp *responses.FPDF_NewXObjectFromPage, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDF_NewXObjectFromPage", panicError)
		}
	}()

	return i.pdfium.FPDF_NewXObjectFromPage(request)
}

func (i *pdfiumInstance) FPDF_PageToDevice(request *requests.FPDF_PageToDevice) (resp *responses.FPDF_PageToDevice, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDF_PageToDevice", panicError)
		}
	}()

	return i.pdfium.FPDF_PageToDevice(request)
}

func (i *pdfiumInstance) FPDF_RenderPage(request *requests.FPDF_RenderPage) (resp *responses.FPDF_RenderPage, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDF_RenderPage", panicError)
		}
	}()

	return i.pdfium.FPDF_RenderPage(request)
}

func (i *pdfiumInstance) FPDF_RenderPageBitmap(request *requests.FPDF_RenderPageBitmap) (resp *responses.FPDF_RenderPageBitmap, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDF_RenderPageBitmap", panicError)
		}
	}()

	return i.pdfium.FPDF_RenderPageBitmap(request)
}

func (i *pdfiumInstance) FPDF_RenderPageBitmapWithColorScheme_Start(request *requests.FPDF_RenderPageBitmapWithColorScheme_Start) (resp *responses.FPDF_RenderPageBitmapWithColorScheme_Start, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDF_RenderPageBitmapWithColorScheme_Start", panicError)
		}
	}()

	return i.pdfium.FPDF_RenderPageBitmapWithColorScheme_Start(request)
}

func (i *pdfiumInstance) FPDF_RenderPageBitmapWithMatrix(request *requests.FPDF_RenderPageBitmapWithMatrix) (resp *responses.FPDF_RenderPageBitmapWithMatrix, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDF_RenderPageBitmapWithMatrix", panicError)
		}
	}()

	return i.pdfium.FPDF_RenderPageBitmapWithMatrix(request)
}

func (i *pdfiumInstance) FPDF_RenderPageBitmap_Start(request *requests.FPDF_RenderPageBitmap_Start) (resp *responses.FPDF_RenderPageBitmap_Start, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDF_RenderPageBitmap_Start", panicError)
		}
	}()

	return i.pdfium.FPDF_RenderPageBitmap_Start(request)
}

func (i *pdfiumInstance) FPDF_RenderPage_Close(request *requests.FPDF_RenderPage_Close) (resp *responses.FPDF_RenderPage_Close, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDF_RenderPage_Close", panicError)
		}
	}()

	return i.pdfium.FPDF_RenderPage_Close(request)
}

func (i *pdfiumInstance) FPDF_RenderPage_Continue(request *requests.FPDF_RenderPage_Continue) (resp *responses.FPDF_RenderPage_Continue, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDF_RenderPage_Continue", panicError)
		}
	}()

	return i.pdfium.FPDF_RenderPage_Continue(request)
}

func (i *pdfiumInstance) FPDF_SaveAsCopy(request *requests.FPDF_SaveAsCopy) (resp *responses.FPDF_SaveAsCopy, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDF_SaveAsCopy", panicError)
		}
	}()

	return i.pdfium.FPDF_SaveAsCopy(request)
}

func (i *pdfiumInstance) FPDF_SaveWithVersion(request *requests.FPDF_SaveWithVersion) (resp *responses.FPDF_SaveWithVersion, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDF_SaveWithVersion", panicError)
		}
	}()

	return i.pdfium.FPDF_SaveWithVersion(request)
}

func (i *pdfiumInstance) FPDF_SetPrintMode(request *requests.FPDF_SetPrintMode) (resp *responses.FPDF_SetPrintMode, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDF_SetPrintMode", panicError)
		}
	}()

	return i.pdfium.FPDF_SetPrintMode(request)
}

func (i *pdfiumInstance) FPDF_SetSandBoxPolicy(request *requests.FPDF_SetSandBoxPolicy) (resp *responses.FPDF_SetSandBoxPolicy, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDF_SetSandBoxPolicy", panicError)
		}
	}()

	return i.pdfium.FPDF_SetSandBoxPolicy(request)
}

func (i *pdfiumInstance) FPDF_StructElement_CountChildren(request *requests.FPDF_StructElement_CountChildren) (resp *responses.FPDF_StructElement_CountChildren, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDF_StructElement_CountChildren", panicError)
		}
	}()

	return i.pdfium.FPDF_StructElement_CountChildren(request)
}

func (i *pdfiumInstance) FPDF_StructElement_GetAltText(request *requests.FPDF_StructElement_GetAltText) (resp *responses.FPDF_StructElement_GetAltText, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDF_StructElement_GetAltText", panicError)
		}
	}()

	return i.pdfium.FPDF_StructElement_GetAltText(request)
}

func (i *pdfiumInstance) FPDF_StructElement_GetChildAtIndex(request *requests.FPDF_StructElement_GetChildAtIndex) (resp *responses.FPDF_StructElement_GetChildAtIndex, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDF_StructElement_GetChildAtIndex", panicError)
		}
	}()

	return i.pdfium.FPDF_StructElement_GetChildAtIndex(request)
}

func (i *pdfiumInstance) FPDF_StructElement_GetID(request *requests.FPDF_StructElement_GetID) (resp *responses.FPDF_StructElement_GetID, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDF_StructElement_GetID", panicError)
		}
	}()

	return i.pdfium.FPDF_StructElement_GetID(request)
}

func (i *pdfiumInstance) FPDF_StructElement_GetLang(request *requests.FPDF_StructElement_GetLang) (resp *responses.FPDF_StructElement_GetLang, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDF_StructElement_GetLang", panicError)
		}
	}()

	return i.pdfium.FPDF_StructElement_GetLang(request)
}

func (i *pdfiumInstance) FPDF_StructElement_GetMarkedContentID(request *requests.FPDF_StructElement_GetMarkedContentID) (resp *responses.FPDF_StructElement_GetMarkedContentID, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDF_StructElement_GetMarkedContentID", panicError)
		}
	}()

	return i.pdfium.FPDF_StructElement_GetMarkedContentID(request)
}

func (i *pdfiumInstance) FPDF_StructElement_GetStringAttribute(request *requests.FPDF_StructElement_GetStringAttribute) (resp *responses.FPDF_StructElement_GetStringAttribute, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDF_StructElement_GetStringAttribute", panicError)
		}
	}()

	return i.pdfium.FPDF_StructElement_GetStringAttribute(request)
}

func (i *pdfiumInstance) FPDF_StructElement_GetTitle(request *requests.FPDF_StructElement_GetTitle) (resp *responses.FPDF_StructElement_GetTitle, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDF_StructElement_GetTitle", panicError)
		}
	}()

	return i.pdfium.FPDF_StructElement_GetTitle(request)
}

func (i *pdfiumInstance) FPDF_StructElement_GetType(request *requests.FPDF_StructElement_GetType) (resp *responses.FPDF_StructElement_GetType, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDF_StructElement_GetType", panicError)
		}
	}()

	return i.pdfium.FPDF_StructElement_GetType(request)
}

func (i *pdfiumInstance) FPDF_StructTree_Close(request *requests.FPDF_StructTree_Close) (resp *responses.FPDF_StructTree_Close, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDF_StructTree_Close", panicError)
		}
	}()

	return i.pdfium.FPDF_StructTree_Close(request)
}

func (i *pdfiumInstance) FPDF_StructTree_CountChildren(request *requests.FPDF_StructTree_CountChildren) (resp *responses.FPDF_StructTree_CountChildren, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDF_StructTree_CountChildren", panicError)
		}
	}()

	return i.pdfium.FPDF_StructTree_CountChildren(request)
}

func (i *pdfiumInstance) FPDF_StructTree_GetChildAtIndex(request *requests.FPDF_StructTree_GetChildAtIndex) (resp *responses.FPDF_StructTree_GetChildAtIndex, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDF_StructTree_GetChildAtIndex", panicError)
		}
	}()

	return i.pdfium.FPDF_StructTree_GetChildAtIndex(request)
}

func (i *pdfiumInstance) FPDF_StructTree_GetForPage(request *requests.FPDF_StructTree_GetForPage) (resp *responses.FPDF_StructTree_GetForPage, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDF_StructTree_GetForPage", panicError)
		}
	}()

	return i.pdfium.FPDF_StructTree_GetForPage(request)
}

func (i *pdfiumInstance) FPDF_VIEWERREF_GetDuplex(request *requests.FPDF_VIEWERREF_GetDuplex) (resp *responses.FPDF_VIEWERREF_GetDuplex, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDF_VIEWERREF_GetDuplex", panicError)
		}
	}()

	return i.pdfium.FPDF_VIEWERREF_GetDuplex(request)
}

func (i *pdfiumInstance) FPDF_VIEWERREF_GetName(request *requests.FPDF_VIEWERREF_GetName) (resp *responses.FPDF_VIEWERREF_GetName, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDF_VIEWERREF_GetName", panicError)
		}
	}()

	return i.pdfium.FPDF_VIEWERREF_GetName(request)
}

func (i *pdfiumInstance) FPDF_VIEWERREF_GetNumCopies(request *requests.FPDF_VIEWERREF_GetNumCopies) (resp *responses.FPDF_VIEWERREF_GetNumCopies, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDF_VIEWERREF_GetNumCopies", panicError)
		}
	}()

	return i.pdfium.FPDF_VIEWERREF_GetNumCopies(request)
}

func (i *pdfiumInstance) FPDF_VIEWERREF_GetPrintPageRange(request *requests.FPDF_VIEWERREF_GetPrintPageRange) (resp *responses.FPDF_VIEWERREF_GetPrintPageRange, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDF_VIEWERREF_GetPrintPageRange", panicError)
		}
	}()

	return i.pdfium.FPDF_VIEWERREF_GetPrintPageRange(request)
}

func (i *pdfiumInstance) FPDF_VIEWERREF_GetPrintPageRangeCount(request *requests.FPDF_VIEWERREF_GetPrintPageRangeCount) (resp *responses.FPDF_VIEWERREF_GetPrintPageRangeCount, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDF_VIEWERREF_GetPrintPageRangeCount", panicError)
		}
	}()

	return i.pdfium.FPDF_VIEWERREF_GetPrintPageRangeCount(request)
}

func (i *pdfiumInstance) FPDF_VIEWERREF_GetPrintPageRangeElement(request *requests.FPDF_VIEWERREF_GetPrintPageRangeElement) (resp *responses.FPDF_VIEWERREF_GetPrintPageRangeElement, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDF_VIEWERREF_GetPrintPageRangeElement", panicError)
		}
	}()

	return i.pdfium.FPDF_VIEWERREF_GetPrintPageRangeElement(request)
}

func (i *pdfiumInstance) FPDF_VIEWERREF_GetPrintScaling(request *requests.FPDF_VIEWERREF_GetPrintScaling) (resp *responses.FPDF_VIEWERREF_GetPrintScaling, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FPDF_VIEWERREF_GetPrintScaling", panicError)
		}
	}()

	return i.pdfium.FPDF_VIEWERREF_GetPrintScaling(request)
}

func (i *pdfiumInstance) FSDK_SetLocaltimeFunction(request *requests.FSDK_SetLocaltimeFunction) (resp *responses.FSDK_SetLocaltimeFunction, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FSDK_SetLocaltimeFunction", panicError)
		}
	}()

	return i.pdfium.FSDK_SetLocaltimeFunction(request)
}

func (i *pdfiumInstance) FSDK_SetTimeFunction(request *requests.FSDK_SetTimeFunction) (resp *responses.FSDK_SetTimeFunction, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FSDK_SetTimeFunction", panicError)
		}
	}()

	return i.pdfium.FSDK_SetTimeFunction(request)
}

func (i *pdfiumInstance) FSDK_SetUnSpObjProcessHandler(request *requests.FSDK_SetUnSpObjProcessHandler) (resp *responses.FSDK_SetUnSpObjProcessHandler, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "FSDK_SetUnSpObjProcessHandler", panicError)
		}
	}()

	return i.pdfium.FSDK_SetUnSpObjProcessHandler(request)
}

func (i *pdfiumInstance) GetActionInfo(request *requests.GetActionInfo) (resp *responses.GetActionInfo, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "GetActionInfo", panicError)
		}
	}()

	return i.pdfium.GetActionInfo(request)
}

func (i *pdfiumInstance) GetAttachments(request *requests.GetAttachments) (resp *responses.GetAttachments, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "GetAttachments", panicError)
		}
	}()

	return i.pdfium.GetAttachments(request)
}

func (i *pdfiumInstance) GetBookmarks(request *requests.GetBookmarks) (resp *responses.GetBookmarks, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "GetBookmarks", panicError)
		}
	}()

	return i.pdfium.GetBookmarks(request)
}

func (i *pdfiumInstance) GetDestInfo(request *requests.GetDestInfo) (resp *responses.GetDestInfo, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "GetDestInfo", panicError)
		}
	}()

	return i.pdfium.GetDestInfo(request)
}

func (i *pdfiumInstance) GetJavaScriptActions(request *requests.GetJavaScriptActions) (resp *responses.GetJavaScriptActions, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "GetJavaScriptActions", panicError)
		}
	}()

	return i.pdfium.GetJavaScriptActions(request)
}

func (i *pdfiumInstance) GetMetaData(request *requests.GetMetaData) (resp *responses.GetMetaData, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "GetMetaData", panicError)
		}
	}()

	return i.pdfium.GetMetaData(request)
}

func (i *pdfiumInstance) GetPageSize(request *requests.GetPageSize) (resp *responses.GetPageSize, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "GetPageSize", panicError)
		}
	}()

	return i.pdfium.GetPageSize(request)
}

func (i *pdfiumInstance) GetPageSizeInPixels(request *requests.GetPageSizeInPixels) (resp *responses.GetPageSizeInPixels, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "GetPageSizeInPixels", panicError)
		}
	}()

	return i.pdfium.GetPageSizeInPixels(request)
}

func (i *pdfiumInstance) GetPageText(request *requests.GetPageText) (resp *responses.GetPageText, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "GetPageText", panicError)
		}
	}()

	return i.pdfium.GetPageText(request)
}

func (i *pdfiumInstance) GetPageTextStructured(request *requests.GetPageTextStructured) (resp *responses.GetPageTextStructured, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "GetPageTextStructured", panicError)
		}
	}()

	return i.pdfium.GetPageTextStructured(request)
}

func (i *pdfiumInstance) OpenDocument(request *requests.OpenDocument) (resp *responses.OpenDocument, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "OpenDocument", panicError)
		}
	}()

	return i.pdfium.OpenDocument(request)
}

func (i *pdfiumInstance) RenderPageInDPI(request *requests.RenderPageInDPI) (resp *responses.RenderPageInDPI, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "RenderPageInDPI", panicError)
		}
	}()

	return i.pdfium.RenderPageInDPI(request)
}

func (i *pdfiumInstance) RenderPageInPixels(request *requests.RenderPageInPixels) (resp *responses.RenderPageInPixels, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "RenderPageInPixels", panicError)
		}
	}()

	return i.pdfium.RenderPageInPixels(request)
}

func (i *pdfiumInstance) RenderPagesInDPI(request *requests.RenderPagesInDPI) (resp *responses.RenderPagesInDPI, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "RenderPagesInDPI", panicError)
		}
	}()

	return i.pdfium.RenderPagesInDPI(request)
}

func (i *pdfiumInstance) RenderPagesInPixels(request *requests.RenderPagesInPixels) (resp *responses.RenderPagesInPixels, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "RenderPagesInPixels", panicError)
		}
	}()

	return i.pdfium.RenderPagesInPixels(request)
}

func (i *pdfiumInstance) RenderToFile(request *requests.RenderToFile) (resp *responses.RenderToFile, err error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	defer func() {
		if panicError := recover(); panicError != nil {
			err = fmt.Errorf("panic occurred in %s: %v", "RenderToFile", panicError)
		}
	}()

	return i.pdfium.RenderToFile(request)
}
