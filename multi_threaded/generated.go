// Code generated by tool. DO NOT EDIT.
// See the code_generation package.

package multi_threaded

import (
	"errors"
	"io/ioutil"

	"github.com/klippa-app/go-pdfium/requests"
	"github.com/klippa-app/go-pdfium/responses"
)

func (i *pdfiumInstance) FPDFAction_GetDest(request *requests.FPDFAction_GetDest) (*responses.FPDFAction_GetDest, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFAction_GetDest(request)
}

func (i *pdfiumInstance) FPDFAction_GetFilePath(request *requests.FPDFAction_GetFilePath) (*responses.FPDFAction_GetFilePath, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFAction_GetFilePath(request)
}

func (i *pdfiumInstance) FPDFAction_GetType(request *requests.FPDFAction_GetType) (*responses.FPDFAction_GetType, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFAction_GetType(request)
}

func (i *pdfiumInstance) FPDFAction_GetURIPath(request *requests.FPDFAction_GetURIPath) (*responses.FPDFAction_GetURIPath, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFAction_GetURIPath(request)
}

func (i *pdfiumInstance) FPDFAttachment_GetFile(request *requests.FPDFAttachment_GetFile) (*responses.FPDFAttachment_GetFile, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFAttachment_GetFile(request)
}

func (i *pdfiumInstance) FPDFAttachment_GetName(request *requests.FPDFAttachment_GetName) (*responses.FPDFAttachment_GetName, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFAttachment_GetName(request)
}

func (i *pdfiumInstance) FPDFAttachment_GetStringValue(request *requests.FPDFAttachment_GetStringValue) (*responses.FPDFAttachment_GetStringValue, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFAttachment_GetStringValue(request)
}

func (i *pdfiumInstance) FPDFAttachment_GetValueType(request *requests.FPDFAttachment_GetValueType) (*responses.FPDFAttachment_GetValueType, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFAttachment_GetValueType(request)
}

func (i *pdfiumInstance) FPDFAttachment_HasKey(request *requests.FPDFAttachment_HasKey) (*responses.FPDFAttachment_HasKey, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFAttachment_HasKey(request)
}

func (i *pdfiumInstance) FPDFAttachment_SetFile(request *requests.FPDFAttachment_SetFile) (*responses.FPDFAttachment_SetFile, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFAttachment_SetFile(request)
}

func (i *pdfiumInstance) FPDFAttachment_SetStringValue(request *requests.FPDFAttachment_SetStringValue) (*responses.FPDFAttachment_SetStringValue, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFAttachment_SetStringValue(request)
}

func (i *pdfiumInstance) FPDFAvail_Create(request *requests.FPDFAvail_Create) (*responses.FPDFAvail_Create, error) {
	return nil, errors.New("unsupported method on multi-threaded usage")
}

func (i *pdfiumInstance) FPDFAvail_Destroy(request *requests.FPDFAvail_Destroy) (*responses.FPDFAvail_Destroy, error) {
	return nil, errors.New("unsupported method on multi-threaded usage")
}

func (i *pdfiumInstance) FPDFAvail_GetDocument(request *requests.FPDFAvail_GetDocument) (*responses.FPDFAvail_GetDocument, error) {
	return nil, errors.New("unsupported method on multi-threaded usage")
}

func (i *pdfiumInstance) FPDFAvail_GetFirstPageNum(request *requests.FPDFAvail_GetFirstPageNum) (*responses.FPDFAvail_GetFirstPageNum, error) {
	return nil, errors.New("unsupported method on multi-threaded usage")
}

func (i *pdfiumInstance) FPDFAvail_IsDocAvail(request *requests.FPDFAvail_IsDocAvail) (*responses.FPDFAvail_IsDocAvail, error) {
	return nil, errors.New("unsupported method on multi-threaded usage")
}

func (i *pdfiumInstance) FPDFAvail_IsFormAvail(request *requests.FPDFAvail_IsFormAvail) (*responses.FPDFAvail_IsFormAvail, error) {
	return nil, errors.New("unsupported method on multi-threaded usage")
}

func (i *pdfiumInstance) FPDFAvail_IsLinearized(request *requests.FPDFAvail_IsLinearized) (*responses.FPDFAvail_IsLinearized, error) {
	return nil, errors.New("unsupported method on multi-threaded usage")
}

func (i *pdfiumInstance) FPDFAvail_IsPageAvail(request *requests.FPDFAvail_IsPageAvail) (*responses.FPDFAvail_IsPageAvail, error) {
	return nil, errors.New("unsupported method on multi-threaded usage")
}

func (i *pdfiumInstance) FPDFBitmap_Create(request *requests.FPDFBitmap_Create) (*responses.FPDFBitmap_Create, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFBitmap_Create(request)
}

func (i *pdfiumInstance) FPDFBitmap_CreateEx(request *requests.FPDFBitmap_CreateEx) (*responses.FPDFBitmap_CreateEx, error) {
	return nil, errors.New("unsupported method on multi-threaded usage")
}

func (i *pdfiumInstance) FPDFBitmap_Destroy(request *requests.FPDFBitmap_Destroy) (*responses.FPDFBitmap_Destroy, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFBitmap_Destroy(request)
}

func (i *pdfiumInstance) FPDFBitmap_FillRect(request *requests.FPDFBitmap_FillRect) (*responses.FPDFBitmap_FillRect, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFBitmap_FillRect(request)
}

func (i *pdfiumInstance) FPDFBitmap_GetBuffer(request *requests.FPDFBitmap_GetBuffer) (*responses.FPDFBitmap_GetBuffer, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFBitmap_GetBuffer(request)
}

func (i *pdfiumInstance) FPDFBitmap_GetFormat(request *requests.FPDFBitmap_GetFormat) (*responses.FPDFBitmap_GetFormat, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFBitmap_GetFormat(request)
}

func (i *pdfiumInstance) FPDFBitmap_GetHeight(request *requests.FPDFBitmap_GetHeight) (*responses.FPDFBitmap_GetHeight, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFBitmap_GetHeight(request)
}

func (i *pdfiumInstance) FPDFBitmap_GetStride(request *requests.FPDFBitmap_GetStride) (*responses.FPDFBitmap_GetStride, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFBitmap_GetStride(request)
}

func (i *pdfiumInstance) FPDFBitmap_GetWidth(request *requests.FPDFBitmap_GetWidth) (*responses.FPDFBitmap_GetWidth, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFBitmap_GetWidth(request)
}

func (i *pdfiumInstance) FPDFBookmark_Find(request *requests.FPDFBookmark_Find) (*responses.FPDFBookmark_Find, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFBookmark_Find(request)
}

func (i *pdfiumInstance) FPDFBookmark_GetAction(request *requests.FPDFBookmark_GetAction) (*responses.FPDFBookmark_GetAction, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFBookmark_GetAction(request)
}

func (i *pdfiumInstance) FPDFBookmark_GetDest(request *requests.FPDFBookmark_GetDest) (*responses.FPDFBookmark_GetDest, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFBookmark_GetDest(request)
}

func (i *pdfiumInstance) FPDFBookmark_GetFirstChild(request *requests.FPDFBookmark_GetFirstChild) (*responses.FPDFBookmark_GetFirstChild, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFBookmark_GetFirstChild(request)
}

func (i *pdfiumInstance) FPDFBookmark_GetNextSibling(request *requests.FPDFBookmark_GetNextSibling) (*responses.FPDFBookmark_GetNextSibling, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFBookmark_GetNextSibling(request)
}

func (i *pdfiumInstance) FPDFBookmark_GetTitle(request *requests.FPDFBookmark_GetTitle) (*responses.FPDFBookmark_GetTitle, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFBookmark_GetTitle(request)
}

func (i *pdfiumInstance) FPDFCatalog_IsTagged(request *requests.FPDFCatalog_IsTagged) (*responses.FPDFCatalog_IsTagged, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFCatalog_IsTagged(request)
}

func (i *pdfiumInstance) FPDFClipPath_CountPathSegments(request *requests.FPDFClipPath_CountPathSegments) (*responses.FPDFClipPath_CountPathSegments, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFClipPath_CountPathSegments(request)
}

func (i *pdfiumInstance) FPDFClipPath_CountPaths(request *requests.FPDFClipPath_CountPaths) (*responses.FPDFClipPath_CountPaths, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFClipPath_CountPaths(request)
}

func (i *pdfiumInstance) FPDFClipPath_GetPathSegment(request *requests.FPDFClipPath_GetPathSegment) (*responses.FPDFClipPath_GetPathSegment, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFClipPath_GetPathSegment(request)
}

func (i *pdfiumInstance) FPDFDest_GetDestPageIndex(request *requests.FPDFDest_GetDestPageIndex) (*responses.FPDFDest_GetDestPageIndex, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFDest_GetDestPageIndex(request)
}

func (i *pdfiumInstance) FPDFDest_GetLocationInPage(request *requests.FPDFDest_GetLocationInPage) (*responses.FPDFDest_GetLocationInPage, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFDest_GetLocationInPage(request)
}

func (i *pdfiumInstance) FPDFDest_GetView(request *requests.FPDFDest_GetView) (*responses.FPDFDest_GetView, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFDest_GetView(request)
}

func (i *pdfiumInstance) FPDFDoc_AddAttachment(request *requests.FPDFDoc_AddAttachment) (*responses.FPDFDoc_AddAttachment, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFDoc_AddAttachment(request)
}

func (i *pdfiumInstance) FPDFDoc_CloseJavaScriptAction(request *requests.FPDFDoc_CloseJavaScriptAction) (*responses.FPDFDoc_CloseJavaScriptAction, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFDoc_CloseJavaScriptAction(request)
}

func (i *pdfiumInstance) FPDFDoc_DeleteAttachment(request *requests.FPDFDoc_DeleteAttachment) (*responses.FPDFDoc_DeleteAttachment, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFDoc_DeleteAttachment(request)
}

func (i *pdfiumInstance) FPDFDoc_GetAttachment(request *requests.FPDFDoc_GetAttachment) (*responses.FPDFDoc_GetAttachment, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFDoc_GetAttachment(request)
}

func (i *pdfiumInstance) FPDFDoc_GetAttachmentCount(request *requests.FPDFDoc_GetAttachmentCount) (*responses.FPDFDoc_GetAttachmentCount, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFDoc_GetAttachmentCount(request)
}

func (i *pdfiumInstance) FPDFDoc_GetJavaScriptAction(request *requests.FPDFDoc_GetJavaScriptAction) (*responses.FPDFDoc_GetJavaScriptAction, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFDoc_GetJavaScriptAction(request)
}

func (i *pdfiumInstance) FPDFDoc_GetJavaScriptActionCount(request *requests.FPDFDoc_GetJavaScriptActionCount) (*responses.FPDFDoc_GetJavaScriptActionCount, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFDoc_GetJavaScriptActionCount(request)
}

func (i *pdfiumInstance) FPDFDoc_GetPageMode(request *requests.FPDFDoc_GetPageMode) (*responses.FPDFDoc_GetPageMode, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFDoc_GetPageMode(request)
}

func (i *pdfiumInstance) FPDFFont_Close(request *requests.FPDFFont_Close) (*responses.FPDFFont_Close, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFFont_Close(request)
}

func (i *pdfiumInstance) FPDFFont_GetAscent(request *requests.FPDFFont_GetAscent) (*responses.FPDFFont_GetAscent, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFFont_GetAscent(request)
}

func (i *pdfiumInstance) FPDFFont_GetDescent(request *requests.FPDFFont_GetDescent) (*responses.FPDFFont_GetDescent, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFFont_GetDescent(request)
}

func (i *pdfiumInstance) FPDFFont_GetFlags(request *requests.FPDFFont_GetFlags) (*responses.FPDFFont_GetFlags, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFFont_GetFlags(request)
}

func (i *pdfiumInstance) FPDFFont_GetFontName(request *requests.FPDFFont_GetFontName) (*responses.FPDFFont_GetFontName, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFFont_GetFontName(request)
}

func (i *pdfiumInstance) FPDFFont_GetGlyphPath(request *requests.FPDFFont_GetGlyphPath) (*responses.FPDFFont_GetGlyphPath, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFFont_GetGlyphPath(request)
}

func (i *pdfiumInstance) FPDFFont_GetGlyphWidth(request *requests.FPDFFont_GetGlyphWidth) (*responses.FPDFFont_GetGlyphWidth, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFFont_GetGlyphWidth(request)
}

func (i *pdfiumInstance) FPDFFont_GetItalicAngle(request *requests.FPDFFont_GetItalicAngle) (*responses.FPDFFont_GetItalicAngle, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFFont_GetItalicAngle(request)
}

func (i *pdfiumInstance) FPDFFont_GetWeight(request *requests.FPDFFont_GetWeight) (*responses.FPDFFont_GetWeight, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFFont_GetWeight(request)
}

func (i *pdfiumInstance) FPDFFormObj_CountObjects(request *requests.FPDFFormObj_CountObjects) (*responses.FPDFFormObj_CountObjects, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFFormObj_CountObjects(request)
}

func (i *pdfiumInstance) FPDFFormObj_GetObject(request *requests.FPDFFormObj_GetObject) (*responses.FPDFFormObj_GetObject, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFFormObj_GetObject(request)
}

func (i *pdfiumInstance) FPDFGlyphPath_CountGlyphSegments(request *requests.FPDFGlyphPath_CountGlyphSegments) (*responses.FPDFGlyphPath_CountGlyphSegments, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFGlyphPath_CountGlyphSegments(request)
}

func (i *pdfiumInstance) FPDFGlyphPath_GetGlyphPathSegment(request *requests.FPDFGlyphPath_GetGlyphPathSegment) (*responses.FPDFGlyphPath_GetGlyphPathSegment, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFGlyphPath_GetGlyphPathSegment(request)
}

func (i *pdfiumInstance) FPDFImageObj_GetBitmap(request *requests.FPDFImageObj_GetBitmap) (*responses.FPDFImageObj_GetBitmap, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFImageObj_GetBitmap(request)
}

func (i *pdfiumInstance) FPDFImageObj_GetImageDataDecoded(request *requests.FPDFImageObj_GetImageDataDecoded) (*responses.FPDFImageObj_GetImageDataDecoded, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFImageObj_GetImageDataDecoded(request)
}

func (i *pdfiumInstance) FPDFImageObj_GetImageDataRaw(request *requests.FPDFImageObj_GetImageDataRaw) (*responses.FPDFImageObj_GetImageDataRaw, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFImageObj_GetImageDataRaw(request)
}

func (i *pdfiumInstance) FPDFImageObj_GetImageFilter(request *requests.FPDFImageObj_GetImageFilter) (*responses.FPDFImageObj_GetImageFilter, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFImageObj_GetImageFilter(request)
}

func (i *pdfiumInstance) FPDFImageObj_GetImageFilterCount(request *requests.FPDFImageObj_GetImageFilterCount) (*responses.FPDFImageObj_GetImageFilterCount, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFImageObj_GetImageFilterCount(request)
}

func (i *pdfiumInstance) FPDFImageObj_GetImageMetadata(request *requests.FPDFImageObj_GetImageMetadata) (*responses.FPDFImageObj_GetImageMetadata, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFImageObj_GetImageMetadata(request)
}

func (i *pdfiumInstance) FPDFImageObj_GetRenderedBitmap(request *requests.FPDFImageObj_GetRenderedBitmap) (*responses.FPDFImageObj_GetRenderedBitmap, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFImageObj_GetRenderedBitmap(request)
}

func (i *pdfiumInstance) FPDFImageObj_LoadJpegFile(request *requests.FPDFImageObj_LoadJpegFile) (*responses.FPDFImageObj_LoadJpegFile, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFImageObj_LoadJpegFile(request)
}

func (i *pdfiumInstance) FPDFImageObj_LoadJpegFileInline(request *requests.FPDFImageObj_LoadJpegFileInline) (*responses.FPDFImageObj_LoadJpegFileInline, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFImageObj_LoadJpegFileInline(request)
}

func (i *pdfiumInstance) FPDFImageObj_SetBitmap(request *requests.FPDFImageObj_SetBitmap) (*responses.FPDFImageObj_SetBitmap, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFImageObj_SetBitmap(request)
}

func (i *pdfiumInstance) FPDFImageObj_SetMatrix(request *requests.FPDFImageObj_SetMatrix) (*responses.FPDFImageObj_SetMatrix, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFImageObj_SetMatrix(request)
}

func (i *pdfiumInstance) FPDFJavaScriptAction_GetName(request *requests.FPDFJavaScriptAction_GetName) (*responses.FPDFJavaScriptAction_GetName, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFJavaScriptAction_GetName(request)
}

func (i *pdfiumInstance) FPDFJavaScriptAction_GetScript(request *requests.FPDFJavaScriptAction_GetScript) (*responses.FPDFJavaScriptAction_GetScript, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFJavaScriptAction_GetScript(request)
}

func (i *pdfiumInstance) FPDFLink_CloseWebLinks(request *requests.FPDFLink_CloseWebLinks) (*responses.FPDFLink_CloseWebLinks, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFLink_CloseWebLinks(request)
}

func (i *pdfiumInstance) FPDFLink_CountQuadPoints(request *requests.FPDFLink_CountQuadPoints) (*responses.FPDFLink_CountQuadPoints, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFLink_CountQuadPoints(request)
}

func (i *pdfiumInstance) FPDFLink_CountRects(request *requests.FPDFLink_CountRects) (*responses.FPDFLink_CountRects, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFLink_CountRects(request)
}

func (i *pdfiumInstance) FPDFLink_CountWebLinks(request *requests.FPDFLink_CountWebLinks) (*responses.FPDFLink_CountWebLinks, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFLink_CountWebLinks(request)
}

func (i *pdfiumInstance) FPDFLink_Enumerate(request *requests.FPDFLink_Enumerate) (*responses.FPDFLink_Enumerate, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFLink_Enumerate(request)
}

func (i *pdfiumInstance) FPDFLink_GetAction(request *requests.FPDFLink_GetAction) (*responses.FPDFLink_GetAction, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFLink_GetAction(request)
}

func (i *pdfiumInstance) FPDFLink_GetAnnot(request *requests.FPDFLink_GetAnnot) (*responses.FPDFLink_GetAnnot, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFLink_GetAnnot(request)
}

func (i *pdfiumInstance) FPDFLink_GetAnnotRect(request *requests.FPDFLink_GetAnnotRect) (*responses.FPDFLink_GetAnnotRect, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFLink_GetAnnotRect(request)
}

func (i *pdfiumInstance) FPDFLink_GetDest(request *requests.FPDFLink_GetDest) (*responses.FPDFLink_GetDest, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFLink_GetDest(request)
}

func (i *pdfiumInstance) FPDFLink_GetLinkAtPoint(request *requests.FPDFLink_GetLinkAtPoint) (*responses.FPDFLink_GetLinkAtPoint, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFLink_GetLinkAtPoint(request)
}

func (i *pdfiumInstance) FPDFLink_GetLinkZOrderAtPoint(request *requests.FPDFLink_GetLinkZOrderAtPoint) (*responses.FPDFLink_GetLinkZOrderAtPoint, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFLink_GetLinkZOrderAtPoint(request)
}

func (i *pdfiumInstance) FPDFLink_GetQuadPoints(request *requests.FPDFLink_GetQuadPoints) (*responses.FPDFLink_GetQuadPoints, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFLink_GetQuadPoints(request)
}

func (i *pdfiumInstance) FPDFLink_GetRect(request *requests.FPDFLink_GetRect) (*responses.FPDFLink_GetRect, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFLink_GetRect(request)
}

func (i *pdfiumInstance) FPDFLink_GetTextRange(request *requests.FPDFLink_GetTextRange) (*responses.FPDFLink_GetTextRange, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFLink_GetTextRange(request)
}

func (i *pdfiumInstance) FPDFLink_GetURL(request *requests.FPDFLink_GetURL) (*responses.FPDFLink_GetURL, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFLink_GetURL(request)
}

func (i *pdfiumInstance) FPDFLink_LoadWebLinks(request *requests.FPDFLink_LoadWebLinks) (*responses.FPDFLink_LoadWebLinks, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFLink_LoadWebLinks(request)
}

func (i *pdfiumInstance) FPDFPageObjMark_CountParams(request *requests.FPDFPageObjMark_CountParams) (*responses.FPDFPageObjMark_CountParams, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFPageObjMark_CountParams(request)
}

func (i *pdfiumInstance) FPDFPageObjMark_GetName(request *requests.FPDFPageObjMark_GetName) (*responses.FPDFPageObjMark_GetName, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFPageObjMark_GetName(request)
}

func (i *pdfiumInstance) FPDFPageObjMark_GetParamBlobValue(request *requests.FPDFPageObjMark_GetParamBlobValue) (*responses.FPDFPageObjMark_GetParamBlobValue, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFPageObjMark_GetParamBlobValue(request)
}

func (i *pdfiumInstance) FPDFPageObjMark_GetParamIntValue(request *requests.FPDFPageObjMark_GetParamIntValue) (*responses.FPDFPageObjMark_GetParamIntValue, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFPageObjMark_GetParamIntValue(request)
}

func (i *pdfiumInstance) FPDFPageObjMark_GetParamKey(request *requests.FPDFPageObjMark_GetParamKey) (*responses.FPDFPageObjMark_GetParamKey, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFPageObjMark_GetParamKey(request)
}

func (i *pdfiumInstance) FPDFPageObjMark_GetParamStringValue(request *requests.FPDFPageObjMark_GetParamStringValue) (*responses.FPDFPageObjMark_GetParamStringValue, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFPageObjMark_GetParamStringValue(request)
}

func (i *pdfiumInstance) FPDFPageObjMark_GetParamValueType(request *requests.FPDFPageObjMark_GetParamValueType) (*responses.FPDFPageObjMark_GetParamValueType, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFPageObjMark_GetParamValueType(request)
}

func (i *pdfiumInstance) FPDFPageObjMark_RemoveParam(request *requests.FPDFPageObjMark_RemoveParam) (*responses.FPDFPageObjMark_RemoveParam, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFPageObjMark_RemoveParam(request)
}

func (i *pdfiumInstance) FPDFPageObjMark_SetBlobParam(request *requests.FPDFPageObjMark_SetBlobParam) (*responses.FPDFPageObjMark_SetBlobParam, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFPageObjMark_SetBlobParam(request)
}

func (i *pdfiumInstance) FPDFPageObjMark_SetIntParam(request *requests.FPDFPageObjMark_SetIntParam) (*responses.FPDFPageObjMark_SetIntParam, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFPageObjMark_SetIntParam(request)
}

func (i *pdfiumInstance) FPDFPageObjMark_SetStringParam(request *requests.FPDFPageObjMark_SetStringParam) (*responses.FPDFPageObjMark_SetStringParam, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFPageObjMark_SetStringParam(request)
}

func (i *pdfiumInstance) FPDFPageObj_AddMark(request *requests.FPDFPageObj_AddMark) (*responses.FPDFPageObj_AddMark, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFPageObj_AddMark(request)
}

func (i *pdfiumInstance) FPDFPageObj_CountMarks(request *requests.FPDFPageObj_CountMarks) (*responses.FPDFPageObj_CountMarks, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFPageObj_CountMarks(request)
}

func (i *pdfiumInstance) FPDFPageObj_CreateNewPath(request *requests.FPDFPageObj_CreateNewPath) (*responses.FPDFPageObj_CreateNewPath, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFPageObj_CreateNewPath(request)
}

func (i *pdfiumInstance) FPDFPageObj_CreateNewRect(request *requests.FPDFPageObj_CreateNewRect) (*responses.FPDFPageObj_CreateNewRect, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFPageObj_CreateNewRect(request)
}

func (i *pdfiumInstance) FPDFPageObj_CreateTextObj(request *requests.FPDFPageObj_CreateTextObj) (*responses.FPDFPageObj_CreateTextObj, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFPageObj_CreateTextObj(request)
}

func (i *pdfiumInstance) FPDFPageObj_Destroy(request *requests.FPDFPageObj_Destroy) (*responses.FPDFPageObj_Destroy, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFPageObj_Destroy(request)
}

func (i *pdfiumInstance) FPDFPageObj_GetBounds(request *requests.FPDFPageObj_GetBounds) (*responses.FPDFPageObj_GetBounds, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFPageObj_GetBounds(request)
}

func (i *pdfiumInstance) FPDFPageObj_GetClipPath(request *requests.FPDFPageObj_GetClipPath) (*responses.FPDFPageObj_GetClipPath, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFPageObj_GetClipPath(request)
}

func (i *pdfiumInstance) FPDFPageObj_GetDashArray(request *requests.FPDFPageObj_GetDashArray) (*responses.FPDFPageObj_GetDashArray, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFPageObj_GetDashArray(request)
}

func (i *pdfiumInstance) FPDFPageObj_GetDashCount(request *requests.FPDFPageObj_GetDashCount) (*responses.FPDFPageObj_GetDashCount, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFPageObj_GetDashCount(request)
}

func (i *pdfiumInstance) FPDFPageObj_GetDashPhase(request *requests.FPDFPageObj_GetDashPhase) (*responses.FPDFPageObj_GetDashPhase, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFPageObj_GetDashPhase(request)
}

func (i *pdfiumInstance) FPDFPageObj_GetFillColor(request *requests.FPDFPageObj_GetFillColor) (*responses.FPDFPageObj_GetFillColor, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFPageObj_GetFillColor(request)
}

func (i *pdfiumInstance) FPDFPageObj_GetLineCap(request *requests.FPDFPageObj_GetLineCap) (*responses.FPDFPageObj_GetLineCap, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFPageObj_GetLineCap(request)
}

func (i *pdfiumInstance) FPDFPageObj_GetLineJoin(request *requests.FPDFPageObj_GetLineJoin) (*responses.FPDFPageObj_GetLineJoin, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFPageObj_GetLineJoin(request)
}

func (i *pdfiumInstance) FPDFPageObj_GetMark(request *requests.FPDFPageObj_GetMark) (*responses.FPDFPageObj_GetMark, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFPageObj_GetMark(request)
}

func (i *pdfiumInstance) FPDFPageObj_GetMatrix(request *requests.FPDFPageObj_GetMatrix) (*responses.FPDFPageObj_GetMatrix, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFPageObj_GetMatrix(request)
}

func (i *pdfiumInstance) FPDFPageObj_GetStrokeColor(request *requests.FPDFPageObj_GetStrokeColor) (*responses.FPDFPageObj_GetStrokeColor, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFPageObj_GetStrokeColor(request)
}

func (i *pdfiumInstance) FPDFPageObj_GetStrokeWidth(request *requests.FPDFPageObj_GetStrokeWidth) (*responses.FPDFPageObj_GetStrokeWidth, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFPageObj_GetStrokeWidth(request)
}

func (i *pdfiumInstance) FPDFPageObj_GetType(request *requests.FPDFPageObj_GetType) (*responses.FPDFPageObj_GetType, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFPageObj_GetType(request)
}

func (i *pdfiumInstance) FPDFPageObj_HasTransparency(request *requests.FPDFPageObj_HasTransparency) (*responses.FPDFPageObj_HasTransparency, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFPageObj_HasTransparency(request)
}

func (i *pdfiumInstance) FPDFPageObj_NewImageObj(request *requests.FPDFPageObj_NewImageObj) (*responses.FPDFPageObj_NewImageObj, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFPageObj_NewImageObj(request)
}

func (i *pdfiumInstance) FPDFPageObj_NewTextObj(request *requests.FPDFPageObj_NewTextObj) (*responses.FPDFPageObj_NewTextObj, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFPageObj_NewTextObj(request)
}

func (i *pdfiumInstance) FPDFPageObj_RemoveMark(request *requests.FPDFPageObj_RemoveMark) (*responses.FPDFPageObj_RemoveMark, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFPageObj_RemoveMark(request)
}

func (i *pdfiumInstance) FPDFPageObj_SetBlendMode(request *requests.FPDFPageObj_SetBlendMode) (*responses.FPDFPageObj_SetBlendMode, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFPageObj_SetBlendMode(request)
}

func (i *pdfiumInstance) FPDFPageObj_SetDashArray(request *requests.FPDFPageObj_SetDashArray) (*responses.FPDFPageObj_SetDashArray, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFPageObj_SetDashArray(request)
}

func (i *pdfiumInstance) FPDFPageObj_SetDashPhase(request *requests.FPDFPageObj_SetDashPhase) (*responses.FPDFPageObj_SetDashPhase, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFPageObj_SetDashPhase(request)
}

func (i *pdfiumInstance) FPDFPageObj_SetFillColor(request *requests.FPDFPageObj_SetFillColor) (*responses.FPDFPageObj_SetFillColor, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFPageObj_SetFillColor(request)
}

func (i *pdfiumInstance) FPDFPageObj_SetLineCap(request *requests.FPDFPageObj_SetLineCap) (*responses.FPDFPageObj_SetLineCap, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFPageObj_SetLineCap(request)
}

func (i *pdfiumInstance) FPDFPageObj_SetLineJoin(request *requests.FPDFPageObj_SetLineJoin) (*responses.FPDFPageObj_SetLineJoin, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFPageObj_SetLineJoin(request)
}

func (i *pdfiumInstance) FPDFPageObj_SetMatrix(request *requests.FPDFPageObj_SetMatrix) (*responses.FPDFPageObj_SetMatrix, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFPageObj_SetMatrix(request)
}

func (i *pdfiumInstance) FPDFPageObj_SetStrokeColor(request *requests.FPDFPageObj_SetStrokeColor) (*responses.FPDFPageObj_SetStrokeColor, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFPageObj_SetStrokeColor(request)
}

func (i *pdfiumInstance) FPDFPageObj_SetStrokeWidth(request *requests.FPDFPageObj_SetStrokeWidth) (*responses.FPDFPageObj_SetStrokeWidth, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFPageObj_SetStrokeWidth(request)
}

func (i *pdfiumInstance) FPDFPageObj_Transform(request *requests.FPDFPageObj_Transform) (*responses.FPDFPageObj_Transform, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFPageObj_Transform(request)
}

func (i *pdfiumInstance) FPDFPageObj_TransformClipPath(request *requests.FPDFPageObj_TransformClipPath) (*responses.FPDFPageObj_TransformClipPath, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFPageObj_TransformClipPath(request)
}

func (i *pdfiumInstance) FPDFPage_CountObjects(request *requests.FPDFPage_CountObjects) (*responses.FPDFPage_CountObjects, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFPage_CountObjects(request)
}

func (i *pdfiumInstance) FPDFPage_Delete(request *requests.FPDFPage_Delete) (*responses.FPDFPage_Delete, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFPage_Delete(request)
}

func (i *pdfiumInstance) FPDFPage_Flatten(request *requests.FPDFPage_Flatten) (*responses.FPDFPage_Flatten, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFPage_Flatten(request)
}

func (i *pdfiumInstance) FPDFPage_GenerateContent(request *requests.FPDFPage_GenerateContent) (*responses.FPDFPage_GenerateContent, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFPage_GenerateContent(request)
}

func (i *pdfiumInstance) FPDFPage_GetArtBox(request *requests.FPDFPage_GetArtBox) (*responses.FPDFPage_GetArtBox, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFPage_GetArtBox(request)
}

func (i *pdfiumInstance) FPDFPage_GetBleedBox(request *requests.FPDFPage_GetBleedBox) (*responses.FPDFPage_GetBleedBox, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFPage_GetBleedBox(request)
}

func (i *pdfiumInstance) FPDFPage_GetCropBox(request *requests.FPDFPage_GetCropBox) (*responses.FPDFPage_GetCropBox, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFPage_GetCropBox(request)
}

func (i *pdfiumInstance) FPDFPage_GetDecodedThumbnailData(request *requests.FPDFPage_GetDecodedThumbnailData) (*responses.FPDFPage_GetDecodedThumbnailData, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFPage_GetDecodedThumbnailData(request)
}

func (i *pdfiumInstance) FPDFPage_GetMediaBox(request *requests.FPDFPage_GetMediaBox) (*responses.FPDFPage_GetMediaBox, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFPage_GetMediaBox(request)
}

func (i *pdfiumInstance) FPDFPage_GetObject(request *requests.FPDFPage_GetObject) (*responses.FPDFPage_GetObject, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFPage_GetObject(request)
}

func (i *pdfiumInstance) FPDFPage_GetRawThumbnailData(request *requests.FPDFPage_GetRawThumbnailData) (*responses.FPDFPage_GetRawThumbnailData, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFPage_GetRawThumbnailData(request)
}

func (i *pdfiumInstance) FPDFPage_GetRotation(request *requests.FPDFPage_GetRotation) (*responses.FPDFPage_GetRotation, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFPage_GetRotation(request)
}

func (i *pdfiumInstance) FPDFPage_GetThumbnailAsBitmap(request *requests.FPDFPage_GetThumbnailAsBitmap) (*responses.FPDFPage_GetThumbnailAsBitmap, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFPage_GetThumbnailAsBitmap(request)
}

func (i *pdfiumInstance) FPDFPage_GetTrimBox(request *requests.FPDFPage_GetTrimBox) (*responses.FPDFPage_GetTrimBox, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFPage_GetTrimBox(request)
}

func (i *pdfiumInstance) FPDFPage_HasTransparency(request *requests.FPDFPage_HasTransparency) (*responses.FPDFPage_HasTransparency, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFPage_HasTransparency(request)
}

func (i *pdfiumInstance) FPDFPage_InsertClipPath(request *requests.FPDFPage_InsertClipPath) (*responses.FPDFPage_InsertClipPath, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFPage_InsertClipPath(request)
}

func (i *pdfiumInstance) FPDFPage_InsertObject(request *requests.FPDFPage_InsertObject) (*responses.FPDFPage_InsertObject, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFPage_InsertObject(request)
}

func (i *pdfiumInstance) FPDFPage_New(request *requests.FPDFPage_New) (*responses.FPDFPage_New, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFPage_New(request)
}

func (i *pdfiumInstance) FPDFPage_RemoveObject(request *requests.FPDFPage_RemoveObject) (*responses.FPDFPage_RemoveObject, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFPage_RemoveObject(request)
}

func (i *pdfiumInstance) FPDFPage_SetArtBox(request *requests.FPDFPage_SetArtBox) (*responses.FPDFPage_SetArtBox, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFPage_SetArtBox(request)
}

func (i *pdfiumInstance) FPDFPage_SetBleedBox(request *requests.FPDFPage_SetBleedBox) (*responses.FPDFPage_SetBleedBox, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFPage_SetBleedBox(request)
}

func (i *pdfiumInstance) FPDFPage_SetCropBox(request *requests.FPDFPage_SetCropBox) (*responses.FPDFPage_SetCropBox, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFPage_SetCropBox(request)
}

func (i *pdfiumInstance) FPDFPage_SetMediaBox(request *requests.FPDFPage_SetMediaBox) (*responses.FPDFPage_SetMediaBox, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFPage_SetMediaBox(request)
}

func (i *pdfiumInstance) FPDFPage_SetRotation(request *requests.FPDFPage_SetRotation) (*responses.FPDFPage_SetRotation, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFPage_SetRotation(request)
}

func (i *pdfiumInstance) FPDFPage_SetTrimBox(request *requests.FPDFPage_SetTrimBox) (*responses.FPDFPage_SetTrimBox, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFPage_SetTrimBox(request)
}

func (i *pdfiumInstance) FPDFPage_TransFormWithClip(request *requests.FPDFPage_TransFormWithClip) (*responses.FPDFPage_TransFormWithClip, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFPage_TransFormWithClip(request)
}

func (i *pdfiumInstance) FPDFPage_TransformAnnots(request *requests.FPDFPage_TransformAnnots) (*responses.FPDFPage_TransformAnnots, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFPage_TransformAnnots(request)
}

func (i *pdfiumInstance) FPDFPathSegment_GetClose(request *requests.FPDFPathSegment_GetClose) (*responses.FPDFPathSegment_GetClose, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFPathSegment_GetClose(request)
}

func (i *pdfiumInstance) FPDFPathSegment_GetPoint(request *requests.FPDFPathSegment_GetPoint) (*responses.FPDFPathSegment_GetPoint, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFPathSegment_GetPoint(request)
}

func (i *pdfiumInstance) FPDFPathSegment_GetType(request *requests.FPDFPathSegment_GetType) (*responses.FPDFPathSegment_GetType, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFPathSegment_GetType(request)
}

func (i *pdfiumInstance) FPDFPath_BezierTo(request *requests.FPDFPath_BezierTo) (*responses.FPDFPath_BezierTo, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFPath_BezierTo(request)
}

func (i *pdfiumInstance) FPDFPath_Close(request *requests.FPDFPath_Close) (*responses.FPDFPath_Close, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFPath_Close(request)
}

func (i *pdfiumInstance) FPDFPath_CountSegments(request *requests.FPDFPath_CountSegments) (*responses.FPDFPath_CountSegments, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFPath_CountSegments(request)
}

func (i *pdfiumInstance) FPDFPath_GetDrawMode(request *requests.FPDFPath_GetDrawMode) (*responses.FPDFPath_GetDrawMode, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFPath_GetDrawMode(request)
}

func (i *pdfiumInstance) FPDFPath_GetPathSegment(request *requests.FPDFPath_GetPathSegment) (*responses.FPDFPath_GetPathSegment, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFPath_GetPathSegment(request)
}

func (i *pdfiumInstance) FPDFPath_LineTo(request *requests.FPDFPath_LineTo) (*responses.FPDFPath_LineTo, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFPath_LineTo(request)
}

func (i *pdfiumInstance) FPDFPath_MoveTo(request *requests.FPDFPath_MoveTo) (*responses.FPDFPath_MoveTo, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFPath_MoveTo(request)
}

func (i *pdfiumInstance) FPDFPath_SetDrawMode(request *requests.FPDFPath_SetDrawMode) (*responses.FPDFPath_SetDrawMode, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFPath_SetDrawMode(request)
}

func (i *pdfiumInstance) FPDFSignatureObj_GetByteRange(request *requests.FPDFSignatureObj_GetByteRange) (*responses.FPDFSignatureObj_GetByteRange, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFSignatureObj_GetByteRange(request)
}

func (i *pdfiumInstance) FPDFSignatureObj_GetContents(request *requests.FPDFSignatureObj_GetContents) (*responses.FPDFSignatureObj_GetContents, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFSignatureObj_GetContents(request)
}

func (i *pdfiumInstance) FPDFSignatureObj_GetDocMDPPermission(request *requests.FPDFSignatureObj_GetDocMDPPermission) (*responses.FPDFSignatureObj_GetDocMDPPermission, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFSignatureObj_GetDocMDPPermission(request)
}

func (i *pdfiumInstance) FPDFSignatureObj_GetReason(request *requests.FPDFSignatureObj_GetReason) (*responses.FPDFSignatureObj_GetReason, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFSignatureObj_GetReason(request)
}

func (i *pdfiumInstance) FPDFSignatureObj_GetSubFilter(request *requests.FPDFSignatureObj_GetSubFilter) (*responses.FPDFSignatureObj_GetSubFilter, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFSignatureObj_GetSubFilter(request)
}

func (i *pdfiumInstance) FPDFSignatureObj_GetTime(request *requests.FPDFSignatureObj_GetTime) (*responses.FPDFSignatureObj_GetTime, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFSignatureObj_GetTime(request)
}

func (i *pdfiumInstance) FPDFTextObj_GetFont(request *requests.FPDFTextObj_GetFont) (*responses.FPDFTextObj_GetFont, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFTextObj_GetFont(request)
}

func (i *pdfiumInstance) FPDFTextObj_GetFontSize(request *requests.FPDFTextObj_GetFontSize) (*responses.FPDFTextObj_GetFontSize, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFTextObj_GetFontSize(request)
}

func (i *pdfiumInstance) FPDFTextObj_GetText(request *requests.FPDFTextObj_GetText) (*responses.FPDFTextObj_GetText, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFTextObj_GetText(request)
}

func (i *pdfiumInstance) FPDFTextObj_GetTextRenderMode(request *requests.FPDFTextObj_GetTextRenderMode) (*responses.FPDFTextObj_GetTextRenderMode, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFTextObj_GetTextRenderMode(request)
}

func (i *pdfiumInstance) FPDFTextObj_SetTextRenderMode(request *requests.FPDFTextObj_SetTextRenderMode) (*responses.FPDFTextObj_SetTextRenderMode, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFTextObj_SetTextRenderMode(request)
}

func (i *pdfiumInstance) FPDFText_ClosePage(request *requests.FPDFText_ClosePage) (*responses.FPDFText_ClosePage, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFText_ClosePage(request)
}

func (i *pdfiumInstance) FPDFText_CountChars(request *requests.FPDFText_CountChars) (*responses.FPDFText_CountChars, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFText_CountChars(request)
}

func (i *pdfiumInstance) FPDFText_CountRects(request *requests.FPDFText_CountRects) (*responses.FPDFText_CountRects, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFText_CountRects(request)
}

func (i *pdfiumInstance) FPDFText_FindClose(request *requests.FPDFText_FindClose) (*responses.FPDFText_FindClose, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFText_FindClose(request)
}

func (i *pdfiumInstance) FPDFText_FindNext(request *requests.FPDFText_FindNext) (*responses.FPDFText_FindNext, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFText_FindNext(request)
}

func (i *pdfiumInstance) FPDFText_FindPrev(request *requests.FPDFText_FindPrev) (*responses.FPDFText_FindPrev, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFText_FindPrev(request)
}

func (i *pdfiumInstance) FPDFText_FindStart(request *requests.FPDFText_FindStart) (*responses.FPDFText_FindStart, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFText_FindStart(request)
}

func (i *pdfiumInstance) FPDFText_GetBoundedText(request *requests.FPDFText_GetBoundedText) (*responses.FPDFText_GetBoundedText, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFText_GetBoundedText(request)
}

func (i *pdfiumInstance) FPDFText_GetCharAngle(request *requests.FPDFText_GetCharAngle) (*responses.FPDFText_GetCharAngle, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFText_GetCharAngle(request)
}

func (i *pdfiumInstance) FPDFText_GetCharBox(request *requests.FPDFText_GetCharBox) (*responses.FPDFText_GetCharBox, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFText_GetCharBox(request)
}

func (i *pdfiumInstance) FPDFText_GetCharIndexAtPos(request *requests.FPDFText_GetCharIndexAtPos) (*responses.FPDFText_GetCharIndexAtPos, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFText_GetCharIndexAtPos(request)
}

func (i *pdfiumInstance) FPDFText_GetCharIndexFromTextIndex(request *requests.FPDFText_GetCharIndexFromTextIndex) (*responses.FPDFText_GetCharIndexFromTextIndex, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFText_GetCharIndexFromTextIndex(request)
}

func (i *pdfiumInstance) FPDFText_GetCharOrigin(request *requests.FPDFText_GetCharOrigin) (*responses.FPDFText_GetCharOrigin, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFText_GetCharOrigin(request)
}

func (i *pdfiumInstance) FPDFText_GetFillColor(request *requests.FPDFText_GetFillColor) (*responses.FPDFText_GetFillColor, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFText_GetFillColor(request)
}

func (i *pdfiumInstance) FPDFText_GetFontInfo(request *requests.FPDFText_GetFontInfo) (*responses.FPDFText_GetFontInfo, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFText_GetFontInfo(request)
}

func (i *pdfiumInstance) FPDFText_GetFontSize(request *requests.FPDFText_GetFontSize) (*responses.FPDFText_GetFontSize, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFText_GetFontSize(request)
}

func (i *pdfiumInstance) FPDFText_GetFontWeight(request *requests.FPDFText_GetFontWeight) (*responses.FPDFText_GetFontWeight, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFText_GetFontWeight(request)
}

func (i *pdfiumInstance) FPDFText_GetLooseCharBox(request *requests.FPDFText_GetLooseCharBox) (*responses.FPDFText_GetLooseCharBox, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFText_GetLooseCharBox(request)
}

func (i *pdfiumInstance) FPDFText_GetMatrix(request *requests.FPDFText_GetMatrix) (*responses.FPDFText_GetMatrix, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFText_GetMatrix(request)
}

func (i *pdfiumInstance) FPDFText_GetRect(request *requests.FPDFText_GetRect) (*responses.FPDFText_GetRect, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFText_GetRect(request)
}

func (i *pdfiumInstance) FPDFText_GetSchCount(request *requests.FPDFText_GetSchCount) (*responses.FPDFText_GetSchCount, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFText_GetSchCount(request)
}

func (i *pdfiumInstance) FPDFText_GetSchResultIndex(request *requests.FPDFText_GetSchResultIndex) (*responses.FPDFText_GetSchResultIndex, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFText_GetSchResultIndex(request)
}

func (i *pdfiumInstance) FPDFText_GetStrokeColor(request *requests.FPDFText_GetStrokeColor) (*responses.FPDFText_GetStrokeColor, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFText_GetStrokeColor(request)
}

func (i *pdfiumInstance) FPDFText_GetText(request *requests.FPDFText_GetText) (*responses.FPDFText_GetText, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFText_GetText(request)
}

func (i *pdfiumInstance) FPDFText_GetTextIndexFromCharIndex(request *requests.FPDFText_GetTextIndexFromCharIndex) (*responses.FPDFText_GetTextIndexFromCharIndex, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFText_GetTextIndexFromCharIndex(request)
}

func (i *pdfiumInstance) FPDFText_GetTextRenderMode(request *requests.FPDFText_GetTextRenderMode) (*responses.FPDFText_GetTextRenderMode, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFText_GetTextRenderMode(request)
}

func (i *pdfiumInstance) FPDFText_GetUnicode(request *requests.FPDFText_GetUnicode) (*responses.FPDFText_GetUnicode, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFText_GetUnicode(request)
}

func (i *pdfiumInstance) FPDFText_LoadFont(request *requests.FPDFText_LoadFont) (*responses.FPDFText_LoadFont, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFText_LoadFont(request)
}

func (i *pdfiumInstance) FPDFText_LoadPage(request *requests.FPDFText_LoadPage) (*responses.FPDFText_LoadPage, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFText_LoadPage(request)
}

func (i *pdfiumInstance) FPDFText_LoadStandardFont(request *requests.FPDFText_LoadStandardFont) (*responses.FPDFText_LoadStandardFont, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFText_LoadStandardFont(request)
}

func (i *pdfiumInstance) FPDFText_SetCharcodes(request *requests.FPDFText_SetCharcodes) (*responses.FPDFText_SetCharcodes, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFText_SetCharcodes(request)
}

func (i *pdfiumInstance) FPDFText_SetText(request *requests.FPDFText_SetText) (*responses.FPDFText_SetText, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDFText_SetText(request)
}

func (i *pdfiumInstance) FPDF_CloseDocument(request *requests.FPDF_CloseDocument) (*responses.FPDF_CloseDocument, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDF_CloseDocument(request)
}

func (i *pdfiumInstance) FPDF_ClosePage(request *requests.FPDF_ClosePage) (*responses.FPDF_ClosePage, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDF_ClosePage(request)
}

func (i *pdfiumInstance) FPDF_CloseXObject(request *requests.FPDF_CloseXObject) (*responses.FPDF_CloseXObject, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDF_CloseXObject(request)
}

func (i *pdfiumInstance) FPDF_CopyViewerPreferences(request *requests.FPDF_CopyViewerPreferences) (*responses.FPDF_CopyViewerPreferences, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDF_CopyViewerPreferences(request)
}

func (i *pdfiumInstance) FPDF_CountNamedDests(request *requests.FPDF_CountNamedDests) (*responses.FPDF_CountNamedDests, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDF_CountNamedDests(request)
}

func (i *pdfiumInstance) FPDF_CreateClipPath(request *requests.FPDF_CreateClipPath) (*responses.FPDF_CreateClipPath, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDF_CreateClipPath(request)
}

func (i *pdfiumInstance) FPDF_CreateNewDocument(request *requests.FPDF_CreateNewDocument) (*responses.FPDF_CreateNewDocument, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDF_CreateNewDocument(request)
}

func (i *pdfiumInstance) FPDF_DestroyClipPath(request *requests.FPDF_DestroyClipPath) (*responses.FPDF_DestroyClipPath, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDF_DestroyClipPath(request)
}

func (i *pdfiumInstance) FPDF_DeviceToPage(request *requests.FPDF_DeviceToPage) (*responses.FPDF_DeviceToPage, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDF_DeviceToPage(request)
}

func (i *pdfiumInstance) FPDF_DocumentHasValidCrossReferenceTable(request *requests.FPDF_DocumentHasValidCrossReferenceTable) (*responses.FPDF_DocumentHasValidCrossReferenceTable, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDF_DocumentHasValidCrossReferenceTable(request)
}

func (i *pdfiumInstance) FPDF_GetDocPermissions(request *requests.FPDF_GetDocPermissions) (*responses.FPDF_GetDocPermissions, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDF_GetDocPermissions(request)
}

func (i *pdfiumInstance) FPDF_GetFileIdentifier(request *requests.FPDF_GetFileIdentifier) (*responses.FPDF_GetFileIdentifier, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDF_GetFileIdentifier(request)
}

func (i *pdfiumInstance) FPDF_GetFileVersion(request *requests.FPDF_GetFileVersion) (*responses.FPDF_GetFileVersion, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDF_GetFileVersion(request)
}

func (i *pdfiumInstance) FPDF_GetLastError(request *requests.FPDF_GetLastError) (*responses.FPDF_GetLastError, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDF_GetLastError(request)
}

func (i *pdfiumInstance) FPDF_GetMetaText(request *requests.FPDF_GetMetaText) (*responses.FPDF_GetMetaText, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDF_GetMetaText(request)
}

func (i *pdfiumInstance) FPDF_GetNamedDest(request *requests.FPDF_GetNamedDest) (*responses.FPDF_GetNamedDest, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDF_GetNamedDest(request)
}

func (i *pdfiumInstance) FPDF_GetNamedDestByName(request *requests.FPDF_GetNamedDestByName) (*responses.FPDF_GetNamedDestByName, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDF_GetNamedDestByName(request)
}

func (i *pdfiumInstance) FPDF_GetPageAAction(request *requests.FPDF_GetPageAAction) (*responses.FPDF_GetPageAAction, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDF_GetPageAAction(request)
}

func (i *pdfiumInstance) FPDF_GetPageBoundingBox(request *requests.FPDF_GetPageBoundingBox) (*responses.FPDF_GetPageBoundingBox, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDF_GetPageBoundingBox(request)
}

func (i *pdfiumInstance) FPDF_GetPageCount(request *requests.FPDF_GetPageCount) (*responses.FPDF_GetPageCount, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDF_GetPageCount(request)
}

func (i *pdfiumInstance) FPDF_GetPageHeight(request *requests.FPDF_GetPageHeight) (*responses.FPDF_GetPageHeight, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDF_GetPageHeight(request)
}

func (i *pdfiumInstance) FPDF_GetPageHeightF(request *requests.FPDF_GetPageHeightF) (*responses.FPDF_GetPageHeightF, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDF_GetPageHeightF(request)
}

func (i *pdfiumInstance) FPDF_GetPageLabel(request *requests.FPDF_GetPageLabel) (*responses.FPDF_GetPageLabel, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDF_GetPageLabel(request)
}

func (i *pdfiumInstance) FPDF_GetPageSizeByIndex(request *requests.FPDF_GetPageSizeByIndex) (*responses.FPDF_GetPageSizeByIndex, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDF_GetPageSizeByIndex(request)
}

func (i *pdfiumInstance) FPDF_GetPageSizeByIndexF(request *requests.FPDF_GetPageSizeByIndexF) (*responses.FPDF_GetPageSizeByIndexF, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDF_GetPageSizeByIndexF(request)
}

func (i *pdfiumInstance) FPDF_GetPageWidth(request *requests.FPDF_GetPageWidth) (*responses.FPDF_GetPageWidth, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDF_GetPageWidth(request)
}

func (i *pdfiumInstance) FPDF_GetPageWidthF(request *requests.FPDF_GetPageWidthF) (*responses.FPDF_GetPageWidthF, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDF_GetPageWidthF(request)
}

func (i *pdfiumInstance) FPDF_GetSecurityHandlerRevision(request *requests.FPDF_GetSecurityHandlerRevision) (*responses.FPDF_GetSecurityHandlerRevision, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDF_GetSecurityHandlerRevision(request)
}

func (i *pdfiumInstance) FPDF_GetSignatureCount(request *requests.FPDF_GetSignatureCount) (*responses.FPDF_GetSignatureCount, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDF_GetSignatureCount(request)
}

func (i *pdfiumInstance) FPDF_GetSignatureObject(request *requests.FPDF_GetSignatureObject) (*responses.FPDF_GetSignatureObject, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDF_GetSignatureObject(request)
}

func (i *pdfiumInstance) FPDF_GetTrailerEnds(request *requests.FPDF_GetTrailerEnds) (*responses.FPDF_GetTrailerEnds, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDF_GetTrailerEnds(request)
}

func (i *pdfiumInstance) FPDF_GetXFAPacketContent(request *requests.FPDF_GetXFAPacketContent) (*responses.FPDF_GetXFAPacketContent, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDF_GetXFAPacketContent(request)
}

func (i *pdfiumInstance) FPDF_GetXFAPacketCount(request *requests.FPDF_GetXFAPacketCount) (*responses.FPDF_GetXFAPacketCount, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDF_GetXFAPacketCount(request)
}

func (i *pdfiumInstance) FPDF_GetXFAPacketName(request *requests.FPDF_GetXFAPacketName) (*responses.FPDF_GetXFAPacketName, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDF_GetXFAPacketName(request)
}

func (i *pdfiumInstance) FPDF_ImportNPagesToOne(request *requests.FPDF_ImportNPagesToOne) (*responses.FPDF_ImportNPagesToOne, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDF_ImportNPagesToOne(request)
}

func (i *pdfiumInstance) FPDF_ImportPages(request *requests.FPDF_ImportPages) (*responses.FPDF_ImportPages, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDF_ImportPages(request)
}

func (i *pdfiumInstance) FPDF_ImportPagesByIndex(request *requests.FPDF_ImportPagesByIndex) (*responses.FPDF_ImportPagesByIndex, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDF_ImportPagesByIndex(request)
}

func (i *pdfiumInstance) FPDF_LoadCustomDocument(request *requests.FPDF_LoadCustomDocument) (*responses.FPDF_LoadCustomDocument, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	// Since multi-threaded usage implements gRPC, it can't serialize the reader onto that.
	// To make it support the full interface, we just rewrite it to OpenDocument,
	// and OpenDocument just fully reads the io.ReadSeeker into an byte array.
	doc, err := i.OpenDocument(&requests.OpenDocument{
		FileReader:     request.Reader,
		FileReaderSize: request.Size,
		Password:       request.Password,
	})
	if err != nil {
		return nil, err
	}

	return &responses.FPDF_LoadCustomDocument{Document: doc.Document}, nil
}

func (i *pdfiumInstance) FPDF_LoadDocument(request *requests.FPDF_LoadDocument) (*responses.FPDF_LoadDocument, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDF_LoadDocument(request)
}

func (i *pdfiumInstance) FPDF_LoadMemDocument(request *requests.FPDF_LoadMemDocument) (*responses.FPDF_LoadMemDocument, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDF_LoadMemDocument(request)
}

func (i *pdfiumInstance) FPDF_LoadMemDocument64(request *requests.FPDF_LoadMemDocument64) (*responses.FPDF_LoadMemDocument64, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDF_LoadMemDocument64(request)
}

func (i *pdfiumInstance) FPDF_LoadPage(request *requests.FPDF_LoadPage) (*responses.FPDF_LoadPage, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDF_LoadPage(request)
}

func (i *pdfiumInstance) FPDF_NewFormObjectFromXObject(request *requests.FPDF_NewFormObjectFromXObject) (*responses.FPDF_NewFormObjectFromXObject, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDF_NewFormObjectFromXObject(request)
}

func (i *pdfiumInstance) FPDF_NewXObjectFromPage(request *requests.FPDF_NewXObjectFromPage) (*responses.FPDF_NewXObjectFromPage, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDF_NewXObjectFromPage(request)
}

func (i *pdfiumInstance) FPDF_PageToDevice(request *requests.FPDF_PageToDevice) (*responses.FPDF_PageToDevice, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDF_PageToDevice(request)
}

func (i *pdfiumInstance) FPDF_RenderPage(request *requests.FPDF_RenderPage) (*responses.FPDF_RenderPage, error) {
	return nil, errors.New("unsupported method on multi-threaded usage")
}

func (i *pdfiumInstance) FPDF_RenderPageBitmap(request *requests.FPDF_RenderPageBitmap) (*responses.FPDF_RenderPageBitmap, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDF_RenderPageBitmap(request)
}

func (i *pdfiumInstance) FPDF_RenderPageBitmapWithColorScheme_Start(request *requests.FPDF_RenderPageBitmapWithColorScheme_Start) (*responses.FPDF_RenderPageBitmapWithColorScheme_Start, error) {
	return nil, errors.New("unsupported method on multi-threaded usage")
}

func (i *pdfiumInstance) FPDF_RenderPageBitmapWithMatrix(request *requests.FPDF_RenderPageBitmapWithMatrix) (*responses.FPDF_RenderPageBitmapWithMatrix, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDF_RenderPageBitmapWithMatrix(request)
}

func (i *pdfiumInstance) FPDF_RenderPageBitmap_Start(request *requests.FPDF_RenderPageBitmap_Start) (*responses.FPDF_RenderPageBitmap_Start, error) {
	return nil, errors.New("unsupported method on multi-threaded usage")
}

func (i *pdfiumInstance) FPDF_RenderPage_Close(request *requests.FPDF_RenderPage_Close) (*responses.FPDF_RenderPage_Close, error) {
	return nil, errors.New("unsupported method on multi-threaded usage")
}

func (i *pdfiumInstance) FPDF_RenderPage_Continue(request *requests.FPDF_RenderPage_Continue) (*responses.FPDF_RenderPage_Continue, error) {
	return nil, errors.New("unsupported method on multi-threaded usage")
}

func (i *pdfiumInstance) FPDF_SaveAsCopy(request *requests.FPDF_SaveAsCopy) (*responses.FPDF_SaveAsCopy, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	if request.FileWriter != nil {
		return nil, errors.New("using a file-writer is not supported on multi-threaded usage")
	}

	return i.worker.plugin.FPDF_SaveAsCopy(request)
}

func (i *pdfiumInstance) FPDF_SaveWithVersion(request *requests.FPDF_SaveWithVersion) (*responses.FPDF_SaveWithVersion, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDF_SaveWithVersion(request)
}

func (i *pdfiumInstance) FPDF_SetPrintMode(request *requests.FPDF_SetPrintMode) (*responses.FPDF_SetPrintMode, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDF_SetPrintMode(request)
}

func (i *pdfiumInstance) FPDF_SetSandBoxPolicy(request *requests.FPDF_SetSandBoxPolicy) (*responses.FPDF_SetSandBoxPolicy, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDF_SetSandBoxPolicy(request)
}

func (i *pdfiumInstance) FPDF_StructElement_CountChildren(request *requests.FPDF_StructElement_CountChildren) (*responses.FPDF_StructElement_CountChildren, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDF_StructElement_CountChildren(request)
}

func (i *pdfiumInstance) FPDF_StructElement_GetAltText(request *requests.FPDF_StructElement_GetAltText) (*responses.FPDF_StructElement_GetAltText, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDF_StructElement_GetAltText(request)
}

func (i *pdfiumInstance) FPDF_StructElement_GetChildAtIndex(request *requests.FPDF_StructElement_GetChildAtIndex) (*responses.FPDF_StructElement_GetChildAtIndex, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDF_StructElement_GetChildAtIndex(request)
}

func (i *pdfiumInstance) FPDF_StructElement_GetID(request *requests.FPDF_StructElement_GetID) (*responses.FPDF_StructElement_GetID, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDF_StructElement_GetID(request)
}

func (i *pdfiumInstance) FPDF_StructElement_GetLang(request *requests.FPDF_StructElement_GetLang) (*responses.FPDF_StructElement_GetLang, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDF_StructElement_GetLang(request)
}

func (i *pdfiumInstance) FPDF_StructElement_GetMarkedContentID(request *requests.FPDF_StructElement_GetMarkedContentID) (*responses.FPDF_StructElement_GetMarkedContentID, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDF_StructElement_GetMarkedContentID(request)
}

func (i *pdfiumInstance) FPDF_StructElement_GetStringAttribute(request *requests.FPDF_StructElement_GetStringAttribute) (*responses.FPDF_StructElement_GetStringAttribute, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDF_StructElement_GetStringAttribute(request)
}

func (i *pdfiumInstance) FPDF_StructElement_GetTitle(request *requests.FPDF_StructElement_GetTitle) (*responses.FPDF_StructElement_GetTitle, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDF_StructElement_GetTitle(request)
}

func (i *pdfiumInstance) FPDF_StructElement_GetType(request *requests.FPDF_StructElement_GetType) (*responses.FPDF_StructElement_GetType, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDF_StructElement_GetType(request)
}

func (i *pdfiumInstance) FPDF_StructTree_Close(request *requests.FPDF_StructTree_Close) (*responses.FPDF_StructTree_Close, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDF_StructTree_Close(request)
}

func (i *pdfiumInstance) FPDF_StructTree_CountChildren(request *requests.FPDF_StructTree_CountChildren) (*responses.FPDF_StructTree_CountChildren, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDF_StructTree_CountChildren(request)
}

func (i *pdfiumInstance) FPDF_StructTree_GetChildAtIndex(request *requests.FPDF_StructTree_GetChildAtIndex) (*responses.FPDF_StructTree_GetChildAtIndex, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDF_StructTree_GetChildAtIndex(request)
}

func (i *pdfiumInstance) FPDF_StructTree_GetForPage(request *requests.FPDF_StructTree_GetForPage) (*responses.FPDF_StructTree_GetForPage, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDF_StructTree_GetForPage(request)
}

func (i *pdfiumInstance) FPDF_VIEWERREF_GetDuplex(request *requests.FPDF_VIEWERREF_GetDuplex) (*responses.FPDF_VIEWERREF_GetDuplex, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDF_VIEWERREF_GetDuplex(request)
}

func (i *pdfiumInstance) FPDF_VIEWERREF_GetName(request *requests.FPDF_VIEWERREF_GetName) (*responses.FPDF_VIEWERREF_GetName, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDF_VIEWERREF_GetName(request)
}

func (i *pdfiumInstance) FPDF_VIEWERREF_GetNumCopies(request *requests.FPDF_VIEWERREF_GetNumCopies) (*responses.FPDF_VIEWERREF_GetNumCopies, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDF_VIEWERREF_GetNumCopies(request)
}

func (i *pdfiumInstance) FPDF_VIEWERREF_GetPrintPageRange(request *requests.FPDF_VIEWERREF_GetPrintPageRange) (*responses.FPDF_VIEWERREF_GetPrintPageRange, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDF_VIEWERREF_GetPrintPageRange(request)
}

func (i *pdfiumInstance) FPDF_VIEWERREF_GetPrintPageRangeCount(request *requests.FPDF_VIEWERREF_GetPrintPageRangeCount) (*responses.FPDF_VIEWERREF_GetPrintPageRangeCount, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDF_VIEWERREF_GetPrintPageRangeCount(request)
}

func (i *pdfiumInstance) FPDF_VIEWERREF_GetPrintPageRangeElement(request *requests.FPDF_VIEWERREF_GetPrintPageRangeElement) (*responses.FPDF_VIEWERREF_GetPrintPageRangeElement, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDF_VIEWERREF_GetPrintPageRangeElement(request)
}

func (i *pdfiumInstance) FPDF_VIEWERREF_GetPrintScaling(request *requests.FPDF_VIEWERREF_GetPrintScaling) (*responses.FPDF_VIEWERREF_GetPrintScaling, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.FPDF_VIEWERREF_GetPrintScaling(request)
}

func (i *pdfiumInstance) FSDK_SetLocaltimeFunction(request *requests.FSDK_SetLocaltimeFunction) (*responses.FSDK_SetLocaltimeFunction, error) {
	return nil, errors.New("unsupported method on multi-threaded usage")
}

func (i *pdfiumInstance) FSDK_SetTimeFunction(request *requests.FSDK_SetTimeFunction) (*responses.FSDK_SetTimeFunction, error) {
	return nil, errors.New("unsupported method on multi-threaded usage")
}

func (i *pdfiumInstance) FSDK_SetUnSpObjProcessHandler(request *requests.FSDK_SetUnSpObjProcessHandler) (*responses.FSDK_SetUnSpObjProcessHandler, error) {
	return nil, errors.New("unsupported method on multi-threaded usage")
}

func (i *pdfiumInstance) GetActionInfo(request *requests.GetActionInfo) (*responses.GetActionInfo, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.GetActionInfo(request)
}

func (i *pdfiumInstance) GetAttachments(request *requests.GetAttachments) (*responses.GetAttachments, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.GetAttachments(request)
}

func (i *pdfiumInstance) GetBookmarks(request *requests.GetBookmarks) (*responses.GetBookmarks, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.GetBookmarks(request)
}

func (i *pdfiumInstance) GetDestInfo(request *requests.GetDestInfo) (*responses.GetDestInfo, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.GetDestInfo(request)
}

func (i *pdfiumInstance) GetJavaScriptActions(request *requests.GetJavaScriptActions) (*responses.GetJavaScriptActions, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.GetJavaScriptActions(request)
}

func (i *pdfiumInstance) GetMetaData(request *requests.GetMetaData) (*responses.GetMetaData, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.GetMetaData(request)
}

func (i *pdfiumInstance) GetPageSize(request *requests.GetPageSize) (*responses.GetPageSize, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.GetPageSize(request)
}

func (i *pdfiumInstance) GetPageSizeInPixels(request *requests.GetPageSizeInPixels) (*responses.GetPageSizeInPixels, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.GetPageSizeInPixels(request)
}

func (i *pdfiumInstance) GetPageText(request *requests.GetPageText) (*responses.GetPageText, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.GetPageText(request)
}

func (i *pdfiumInstance) GetPageTextStructured(request *requests.GetPageTextStructured) (*responses.GetPageTextStructured, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.GetPageTextStructured(request)
}

func (i *pdfiumInstance) OpenDocument(request *requests.OpenDocument) (*responses.OpenDocument, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	// Since multi-threaded usage implements gRPC, it can't serialize the reader onto that.
	// To make it support the full interface, we just fully reads the io.ReadSeeker into
	// an byte array.
	if request.FileReader != nil {
		fileData, err := ioutil.ReadAll(request.FileReader)
		if err != nil {
			return nil, err
		}
		request.FileReader = nil
		request.FileReaderSize = 0
		request.File = &fileData
	}
	return i.worker.plugin.OpenDocument(request)
}

func (i *pdfiumInstance) RenderPageInDPI(request *requests.RenderPageInDPI) (*responses.RenderPageInDPI, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.RenderPageInDPI(request)
}

func (i *pdfiumInstance) RenderPageInPixels(request *requests.RenderPageInPixels) (*responses.RenderPageInPixels, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.RenderPageInPixels(request)
}

func (i *pdfiumInstance) RenderPagesInDPI(request *requests.RenderPagesInDPI) (*responses.RenderPagesInDPI, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.RenderPagesInDPI(request)
}

func (i *pdfiumInstance) RenderPagesInPixels(request *requests.RenderPagesInPixels) (*responses.RenderPagesInPixels, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.RenderPagesInPixels(request)
}

func (i *pdfiumInstance) RenderToFile(request *requests.RenderToFile) (*responses.RenderToFile, error) {
	if i.closed {
		return nil, errors.New("instance is closed")
	}

	return i.worker.plugin.RenderToFile(request)
}
